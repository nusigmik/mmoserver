// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTOCOLSS_PROTOCOLSS_H_
#define FLATBUFFERS_GENERATED_PROTOCOLSS_PROTOCOLSS_H_

#include "flatbuffers/flatbuffers.h"

namespace ProtocolSS {

struct TestMessage;
struct TestMessageT;

struct Notify_UnauthedAccess;
struct Notify_UnauthedAccessT;

struct Request_Login;
struct Request_LoginT;

struct Reply_Login;
struct Reply_LoginT;

struct Request_GenerateCredential;
struct Request_GenerateCredentialT;

struct Reply_GenerateCredential;
struct Reply_GenerateCredentialT;

struct Request_VerifyCredential;
struct Request_VerifyCredentialT;

struct Reply_VerifyCredential;
struct Reply_VerifyCredentialT;

struct Notify_UserLogout;
struct Notify_UserLogoutT;

struct ServerInfo;
struct ServerInfoT;

struct Notify_ServerList;
struct Notify_ServerListT;

struct RelayMessage;
struct RelayMessageT;

struct MessageRoot;
struct MessageRootT;

enum class ErrorCode : int32_t {
  OK = 0,
  UNEXPECTED = 1,
  DATABASE_FAILED = 2,
  INVALID_SESSION = 10,
  INVALID_STRING = 20,
  LOGIN_CONNECTION_FAILED = 100,
  LOGIN_ALREADY_CONNECTED = 101,
  LOGIN_NAME_DUPLICATION = 102,
  VERIFY_CREDENTIAL_FAILED = 103,
  MIN = OK,
  MAX = VERIFY_CREDENTIAL_FAILED
};

enum class MessageType : uint8_t {
  NONE = 0,
  RelayMessage = 1,
  TestMessage = 2,
  Notify_UnauthedAccess = 3,
  Request_Login = 4,
  Reply_Login = 5,
  Request_GenerateCredential = 6,
  Reply_GenerateCredential = 7,
  Request_VerifyCredential = 8,
  Reply_VerifyCredential = 9,
  Notify_UserLogout = 10,
  Notify_ServerList = 11,
  MIN = NONE,
  MAX = Notify_ServerList
};

inline const char **EnumNamesMessageType() {
  static const char *names[] = {
    "NONE",
    "RelayMessage",
    "TestMessage",
    "Notify_UnauthedAccess",
    "Request_Login",
    "Reply_Login",
    "Request_GenerateCredential",
    "Reply_GenerateCredential",
    "Request_VerifyCredential",
    "Reply_VerifyCredential",
    "Notify_UserLogout",
    "Notify_ServerList",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageType()[index];
}

template<typename T> struct MessageTypeTraits {
  static const MessageType enum_value = MessageType::NONE;
};

template<> struct MessageTypeTraits<RelayMessage> {
  static const MessageType enum_value = MessageType::RelayMessage;
};

template<> struct MessageTypeTraits<ProtocolSS::TestMessage> {
  static const MessageType enum_value = MessageType::TestMessage;
};

template<> struct MessageTypeTraits<ProtocolSS::Notify_UnauthedAccess> {
  static const MessageType enum_value = MessageType::Notify_UnauthedAccess;
};

template<> struct MessageTypeTraits<ProtocolSS::Request_Login> {
  static const MessageType enum_value = MessageType::Request_Login;
};

template<> struct MessageTypeTraits<ProtocolSS::Reply_Login> {
  static const MessageType enum_value = MessageType::Reply_Login;
};

template<> struct MessageTypeTraits<ProtocolSS::Request_GenerateCredential> {
  static const MessageType enum_value = MessageType::Request_GenerateCredential;
};

template<> struct MessageTypeTraits<ProtocolSS::Reply_GenerateCredential> {
  static const MessageType enum_value = MessageType::Reply_GenerateCredential;
};

template<> struct MessageTypeTraits<ProtocolSS::Request_VerifyCredential> {
  static const MessageType enum_value = MessageType::Request_VerifyCredential;
};

template<> struct MessageTypeTraits<ProtocolSS::Reply_VerifyCredential> {
  static const MessageType enum_value = MessageType::Reply_VerifyCredential;
};

template<> struct MessageTypeTraits<ProtocolSS::Notify_UserLogout> {
  static const MessageType enum_value = MessageType::Notify_UserLogout;
};

template<> struct MessageTypeTraits<ProtocolSS::Notify_ServerList> {
  static const MessageType enum_value = MessageType::Notify_ServerList;
};

struct MessageTypeUnion {
  MessageType type;
  void *value;

  MessageTypeUnion() : type(MessageType::NONE), value(nullptr) {}
  MessageTypeUnion(MessageTypeUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(MessageType::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MessageTypeUnion(const MessageTypeUnion &) FLATBUFFERS_NOEXCEPT;
  MessageTypeUnion &operator=(const MessageTypeUnion &u) FLATBUFFERS_NOEXCEPT
    { MessageTypeUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MessageTypeUnion &operator=(MessageTypeUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MessageTypeUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    Reset();
    type = MessageTypeTraits<typename T::TableType>::enum_value;
    if (type != MessageType::NONE) {
      value = new T(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, MessageType type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  RelayMessageT *AsRelayMessage() {
    return type == MessageType::RelayMessage ?
      reinterpret_cast<RelayMessageT *>(value) : nullptr;
  }
  ProtocolSS::TestMessageT *AsTestMessage() {
    return type == MessageType::TestMessage ?
      reinterpret_cast<ProtocolSS::TestMessageT *>(value) : nullptr;
  }
  ProtocolSS::Notify_UnauthedAccessT *AsNotify_UnauthedAccess() {
    return type == MessageType::Notify_UnauthedAccess ?
      reinterpret_cast<ProtocolSS::Notify_UnauthedAccessT *>(value) : nullptr;
  }
  ProtocolSS::Request_LoginT *AsRequest_Login() {
    return type == MessageType::Request_Login ?
      reinterpret_cast<ProtocolSS::Request_LoginT *>(value) : nullptr;
  }
  ProtocolSS::Reply_LoginT *AsReply_Login() {
    return type == MessageType::Reply_Login ?
      reinterpret_cast<ProtocolSS::Reply_LoginT *>(value) : nullptr;
  }
  ProtocolSS::Request_GenerateCredentialT *AsRequest_GenerateCredential() {
    return type == MessageType::Request_GenerateCredential ?
      reinterpret_cast<ProtocolSS::Request_GenerateCredentialT *>(value) : nullptr;
  }
  ProtocolSS::Reply_GenerateCredentialT *AsReply_GenerateCredential() {
    return type == MessageType::Reply_GenerateCredential ?
      reinterpret_cast<ProtocolSS::Reply_GenerateCredentialT *>(value) : nullptr;
  }
  ProtocolSS::Request_VerifyCredentialT *AsRequest_VerifyCredential() {
    return type == MessageType::Request_VerifyCredential ?
      reinterpret_cast<ProtocolSS::Request_VerifyCredentialT *>(value) : nullptr;
  }
  ProtocolSS::Reply_VerifyCredentialT *AsReply_VerifyCredential() {
    return type == MessageType::Reply_VerifyCredential ?
      reinterpret_cast<ProtocolSS::Reply_VerifyCredentialT *>(value) : nullptr;
  }
  ProtocolSS::Notify_UserLogoutT *AsNotify_UserLogout() {
    return type == MessageType::Notify_UserLogout ?
      reinterpret_cast<ProtocolSS::Notify_UserLogoutT *>(value) : nullptr;
  }
  ProtocolSS::Notify_ServerListT *AsNotify_ServerList() {
    return type == MessageType::Notify_ServerList ?
      reinterpret_cast<ProtocolSS::Notify_ServerListT *>(value) : nullptr;
  }
};

bool VerifyMessageType(flatbuffers::Verifier &verifier, const void *obj, MessageType type);
bool VerifyMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct TestMessageT : public flatbuffers::NativeTable {
  typedef TestMessage TableType;
  std::string str_msg;
  TestMessageT() {
  }
};

struct TestMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TestMessageT NativeTableType;
  enum {
    VT_STR_MSG = 4
  };
  const flatbuffers::String *str_msg() const {
    return GetPointer<const flatbuffers::String *>(VT_STR_MSG);
  }
  flatbuffers::String *mutable_str_msg() {
    return GetPointer<flatbuffers::String *>(VT_STR_MSG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STR_MSG) &&
           verifier.Verify(str_msg()) &&
           verifier.EndTable();
  }
  TestMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TestMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TestMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TestMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TestMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_str_msg(flatbuffers::Offset<flatbuffers::String> str_msg) {
    fbb_.AddOffset(TestMessage::VT_STR_MSG, str_msg);
  }
  TestMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TestMessageBuilder &operator=(const TestMessageBuilder &);
  flatbuffers::Offset<TestMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<TestMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<TestMessage> CreateTestMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> str_msg = 0) {
  TestMessageBuilder builder_(_fbb);
  builder_.add_str_msg(str_msg);
  return builder_.Finish();
}

inline flatbuffers::Offset<TestMessage> CreateTestMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *str_msg = nullptr) {
  return ProtocolSS::CreateTestMessage(
      _fbb,
      str_msg ? _fbb.CreateString(str_msg) : 0);
}

flatbuffers::Offset<TestMessage> CreateTestMessage(flatbuffers::FlatBufferBuilder &_fbb, const TestMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_UnauthedAccessT : public flatbuffers::NativeTable {
  typedef Notify_UnauthedAccess TableType;
  Notify_UnauthedAccessT() {
  }
};

struct Notify_UnauthedAccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_UnauthedAccessT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Notify_UnauthedAccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_UnauthedAccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_UnauthedAccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_UnauthedAccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Notify_UnauthedAccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_UnauthedAccessBuilder &operator=(const Notify_UnauthedAccessBuilder &);
  flatbuffers::Offset<Notify_UnauthedAccess> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Notify_UnauthedAccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_UnauthedAccess> CreateNotify_UnauthedAccess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Notify_UnauthedAccessBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Notify_UnauthedAccess> CreateNotify_UnauthedAccess(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_LoginT : public flatbuffers::NativeTable {
  typedef Request_Login TableType;
  std::string client_name;
  int32_t client_type;
  Request_LoginT()
      : client_type(0) {
  }
};

struct Request_Login FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_LoginT NativeTableType;
  enum {
    VT_CLIENT_NAME = 4,
    VT_CLIENT_TYPE = 6
  };
  const flatbuffers::String *client_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENT_NAME);
  }
  flatbuffers::String *mutable_client_name() {
    return GetPointer<flatbuffers::String *>(VT_CLIENT_NAME);
  }
  int32_t client_type() const {
    return GetField<int32_t>(VT_CLIENT_TYPE, 0);
  }
  bool mutate_client_type(int32_t _client_type) {
    return SetField<int32_t>(VT_CLIENT_TYPE, _client_type, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLIENT_NAME) &&
           verifier.Verify(client_name()) &&
           VerifyField<int32_t>(verifier, VT_CLIENT_TYPE) &&
           verifier.EndTable();
  }
  Request_LoginT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_LoginT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Login> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_LoginBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_client_name(flatbuffers::Offset<flatbuffers::String> client_name) {
    fbb_.AddOffset(Request_Login::VT_CLIENT_NAME, client_name);
  }
  void add_client_type(int32_t client_type) {
    fbb_.AddElement<int32_t>(Request_Login::VT_CLIENT_TYPE, client_type, 0);
  }
  Request_LoginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_LoginBuilder &operator=(const Request_LoginBuilder &);
  flatbuffers::Offset<Request_Login> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Request_Login>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Login> CreateRequest_Login(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> client_name = 0,
    int32_t client_type = 0) {
  Request_LoginBuilder builder_(_fbb);
  builder_.add_client_type(client_type);
  builder_.add_client_name(client_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Login> CreateRequest_LoginDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *client_name = nullptr,
    int32_t client_type = 0) {
  return ProtocolSS::CreateRequest_Login(
      _fbb,
      client_name ? _fbb.CreateString(client_name) : 0,
      client_type);
}

flatbuffers::Offset<Request_Login> CreateRequest_Login(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_LoginT : public flatbuffers::NativeTable {
  typedef Reply_Login TableType;
  ErrorCode error_code;
  int32_t session_id;
  Reply_LoginT()
      : error_code(ErrorCode::OK),
        session_id(0) {
  }
};

struct Reply_Login FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_LoginT NativeTableType;
  enum {
    VT_ERROR_CODE = 4,
    VT_SESSION_ID = 6
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  int32_t session_id() const {
    return GetField<int32_t>(VT_SESSION_ID, 0);
  }
  bool mutate_session_id(int32_t _session_id) {
    return SetField<int32_t>(VT_SESSION_ID, _session_id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           VerifyField<int32_t>(verifier, VT_SESSION_ID) &&
           verifier.EndTable();
  }
  Reply_LoginT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_LoginT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_Login> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_LoginBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_Login::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  void add_session_id(int32_t session_id) {
    fbb_.AddElement<int32_t>(Reply_Login::VT_SESSION_ID, session_id, 0);
  }
  Reply_LoginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_LoginBuilder &operator=(const Reply_LoginBuilder &);
  flatbuffers::Offset<Reply_Login> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Reply_Login>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_Login> CreateReply_Login(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode::OK,
    int32_t session_id = 0) {
  Reply_LoginBuilder builder_(_fbb);
  builder_.add_session_id(session_id);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_Login> CreateReply_Login(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_GenerateCredentialT : public flatbuffers::NativeTable {
  typedef Request_GenerateCredential TableType;
  int32_t session_id;
  int32_t account_uid;
  Request_GenerateCredentialT()
      : session_id(0),
        account_uid(0) {
  }
};

struct Request_GenerateCredential FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_GenerateCredentialT NativeTableType;
  enum {
    VT_SESSION_ID = 4,
    VT_ACCOUNT_UID = 6
  };
  int32_t session_id() const {
    return GetField<int32_t>(VT_SESSION_ID, 0);
  }
  bool mutate_session_id(int32_t _session_id) {
    return SetField<int32_t>(VT_SESSION_ID, _session_id, 0);
  }
  int32_t account_uid() const {
    return GetField<int32_t>(VT_ACCOUNT_UID, 0);
  }
  bool mutate_account_uid(int32_t _account_uid) {
    return SetField<int32_t>(VT_ACCOUNT_UID, _account_uid, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SESSION_ID) &&
           VerifyField<int32_t>(verifier, VT_ACCOUNT_UID) &&
           verifier.EndTable();
  }
  Request_GenerateCredentialT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_GenerateCredentialT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_GenerateCredential> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_GenerateCredentialT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_GenerateCredentialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_session_id(int32_t session_id) {
    fbb_.AddElement<int32_t>(Request_GenerateCredential::VT_SESSION_ID, session_id, 0);
  }
  void add_account_uid(int32_t account_uid) {
    fbb_.AddElement<int32_t>(Request_GenerateCredential::VT_ACCOUNT_UID, account_uid, 0);
  }
  Request_GenerateCredentialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_GenerateCredentialBuilder &operator=(const Request_GenerateCredentialBuilder &);
  flatbuffers::Offset<Request_GenerateCredential> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Request_GenerateCredential>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_GenerateCredential> CreateRequest_GenerateCredential(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t session_id = 0,
    int32_t account_uid = 0) {
  Request_GenerateCredentialBuilder builder_(_fbb);
  builder_.add_account_uid(account_uid);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

flatbuffers::Offset<Request_GenerateCredential> CreateRequest_GenerateCredential(flatbuffers::FlatBufferBuilder &_fbb, const Request_GenerateCredentialT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_GenerateCredentialT : public flatbuffers::NativeTable {
  typedef Reply_GenerateCredential TableType;
  int32_t session_id;
  std::string credential;
  Reply_GenerateCredentialT()
      : session_id(0) {
  }
};

struct Reply_GenerateCredential FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_GenerateCredentialT NativeTableType;
  enum {
    VT_SESSION_ID = 4,
    VT_CREDENTIAL = 6
  };
  int32_t session_id() const {
    return GetField<int32_t>(VT_SESSION_ID, 0);
  }
  bool mutate_session_id(int32_t _session_id) {
    return SetField<int32_t>(VT_SESSION_ID, _session_id, 0);
  }
  const flatbuffers::String *credential() const {
    return GetPointer<const flatbuffers::String *>(VT_CREDENTIAL);
  }
  flatbuffers::String *mutable_credential() {
    return GetPointer<flatbuffers::String *>(VT_CREDENTIAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SESSION_ID) &&
           VerifyOffset(verifier, VT_CREDENTIAL) &&
           verifier.Verify(credential()) &&
           verifier.EndTable();
  }
  Reply_GenerateCredentialT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_GenerateCredentialT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_GenerateCredential> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_GenerateCredentialT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_GenerateCredentialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_session_id(int32_t session_id) {
    fbb_.AddElement<int32_t>(Reply_GenerateCredential::VT_SESSION_ID, session_id, 0);
  }
  void add_credential(flatbuffers::Offset<flatbuffers::String> credential) {
    fbb_.AddOffset(Reply_GenerateCredential::VT_CREDENTIAL, credential);
  }
  Reply_GenerateCredentialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_GenerateCredentialBuilder &operator=(const Reply_GenerateCredentialBuilder &);
  flatbuffers::Offset<Reply_GenerateCredential> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Reply_GenerateCredential>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_GenerateCredential> CreateReply_GenerateCredential(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t session_id = 0,
    flatbuffers::Offset<flatbuffers::String> credential = 0) {
  Reply_GenerateCredentialBuilder builder_(_fbb);
  builder_.add_credential(credential);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reply_GenerateCredential> CreateReply_GenerateCredentialDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t session_id = 0,
    const char *credential = nullptr) {
  return ProtocolSS::CreateReply_GenerateCredential(
      _fbb,
      session_id,
      credential ? _fbb.CreateString(credential) : 0);
}

flatbuffers::Offset<Reply_GenerateCredential> CreateReply_GenerateCredential(flatbuffers::FlatBufferBuilder &_fbb, const Reply_GenerateCredentialT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_VerifyCredentialT : public flatbuffers::NativeTable {
  typedef Request_VerifyCredential TableType;
  int32_t session_id;
  std::string credential;
  Request_VerifyCredentialT()
      : session_id(0) {
  }
};

struct Request_VerifyCredential FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_VerifyCredentialT NativeTableType;
  enum {
    VT_SESSION_ID = 4,
    VT_CREDENTIAL = 6
  };
  int32_t session_id() const {
    return GetField<int32_t>(VT_SESSION_ID, 0);
  }
  bool mutate_session_id(int32_t _session_id) {
    return SetField<int32_t>(VT_SESSION_ID, _session_id, 0);
  }
  const flatbuffers::String *credential() const {
    return GetPointer<const flatbuffers::String *>(VT_CREDENTIAL);
  }
  flatbuffers::String *mutable_credential() {
    return GetPointer<flatbuffers::String *>(VT_CREDENTIAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SESSION_ID) &&
           VerifyOffset(verifier, VT_CREDENTIAL) &&
           verifier.Verify(credential()) &&
           verifier.EndTable();
  }
  Request_VerifyCredentialT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_VerifyCredentialT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_VerifyCredential> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_VerifyCredentialT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_VerifyCredentialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_session_id(int32_t session_id) {
    fbb_.AddElement<int32_t>(Request_VerifyCredential::VT_SESSION_ID, session_id, 0);
  }
  void add_credential(flatbuffers::Offset<flatbuffers::String> credential) {
    fbb_.AddOffset(Request_VerifyCredential::VT_CREDENTIAL, credential);
  }
  Request_VerifyCredentialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_VerifyCredentialBuilder &operator=(const Request_VerifyCredentialBuilder &);
  flatbuffers::Offset<Request_VerifyCredential> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Request_VerifyCredential>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_VerifyCredential> CreateRequest_VerifyCredential(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t session_id = 0,
    flatbuffers::Offset<flatbuffers::String> credential = 0) {
  Request_VerifyCredentialBuilder builder_(_fbb);
  builder_.add_credential(credential);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_VerifyCredential> CreateRequest_VerifyCredentialDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t session_id = 0,
    const char *credential = nullptr) {
  return ProtocolSS::CreateRequest_VerifyCredential(
      _fbb,
      session_id,
      credential ? _fbb.CreateString(credential) : 0);
}

flatbuffers::Offset<Request_VerifyCredential> CreateRequest_VerifyCredential(flatbuffers::FlatBufferBuilder &_fbb, const Request_VerifyCredentialT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_VerifyCredentialT : public flatbuffers::NativeTable {
  typedef Reply_VerifyCredential TableType;
  ErrorCode error_code;
  int32_t session_id;
  std::string credential;
  int32_t account_uid;
  Reply_VerifyCredentialT()
      : error_code(ErrorCode::OK),
        session_id(0),
        account_uid(0) {
  }
};

struct Reply_VerifyCredential FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_VerifyCredentialT NativeTableType;
  enum {
    VT_ERROR_CODE = 4,
    VT_SESSION_ID = 6,
    VT_CREDENTIAL = 8,
    VT_ACCOUNT_UID = 10
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  int32_t session_id() const {
    return GetField<int32_t>(VT_SESSION_ID, 0);
  }
  bool mutate_session_id(int32_t _session_id) {
    return SetField<int32_t>(VT_SESSION_ID, _session_id, 0);
  }
  const flatbuffers::String *credential() const {
    return GetPointer<const flatbuffers::String *>(VT_CREDENTIAL);
  }
  flatbuffers::String *mutable_credential() {
    return GetPointer<flatbuffers::String *>(VT_CREDENTIAL);
  }
  int32_t account_uid() const {
    return GetField<int32_t>(VT_ACCOUNT_UID, 0);
  }
  bool mutate_account_uid(int32_t _account_uid) {
    return SetField<int32_t>(VT_ACCOUNT_UID, _account_uid, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           VerifyField<int32_t>(verifier, VT_SESSION_ID) &&
           VerifyOffset(verifier, VT_CREDENTIAL) &&
           verifier.Verify(credential()) &&
           VerifyField<int32_t>(verifier, VT_ACCOUNT_UID) &&
           verifier.EndTable();
  }
  Reply_VerifyCredentialT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_VerifyCredentialT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_VerifyCredential> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_VerifyCredentialT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_VerifyCredentialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_VerifyCredential::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  void add_session_id(int32_t session_id) {
    fbb_.AddElement<int32_t>(Reply_VerifyCredential::VT_SESSION_ID, session_id, 0);
  }
  void add_credential(flatbuffers::Offset<flatbuffers::String> credential) {
    fbb_.AddOffset(Reply_VerifyCredential::VT_CREDENTIAL, credential);
  }
  void add_account_uid(int32_t account_uid) {
    fbb_.AddElement<int32_t>(Reply_VerifyCredential::VT_ACCOUNT_UID, account_uid, 0);
  }
  Reply_VerifyCredentialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_VerifyCredentialBuilder &operator=(const Reply_VerifyCredentialBuilder &);
  flatbuffers::Offset<Reply_VerifyCredential> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Reply_VerifyCredential>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_VerifyCredential> CreateReply_VerifyCredential(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode::OK,
    int32_t session_id = 0,
    flatbuffers::Offset<flatbuffers::String> credential = 0,
    int32_t account_uid = 0) {
  Reply_VerifyCredentialBuilder builder_(_fbb);
  builder_.add_account_uid(account_uid);
  builder_.add_credential(credential);
  builder_.add_session_id(session_id);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reply_VerifyCredential> CreateReply_VerifyCredentialDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode::OK,
    int32_t session_id = 0,
    const char *credential = nullptr,
    int32_t account_uid = 0) {
  return ProtocolSS::CreateReply_VerifyCredential(
      _fbb,
      error_code,
      session_id,
      credential ? _fbb.CreateString(credential) : 0,
      account_uid);
}

flatbuffers::Offset<Reply_VerifyCredential> CreateReply_VerifyCredential(flatbuffers::FlatBufferBuilder &_fbb, const Reply_VerifyCredentialT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_UserLogoutT : public flatbuffers::NativeTable {
  typedef Notify_UserLogout TableType;
  int32_t account_uid;
  Notify_UserLogoutT()
      : account_uid(0) {
  }
};

struct Notify_UserLogout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_UserLogoutT NativeTableType;
  enum {
    VT_ACCOUNT_UID = 4
  };
  int32_t account_uid() const {
    return GetField<int32_t>(VT_ACCOUNT_UID, 0);
  }
  bool mutate_account_uid(int32_t _account_uid) {
    return SetField<int32_t>(VT_ACCOUNT_UID, _account_uid, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ACCOUNT_UID) &&
           verifier.EndTable();
  }
  Notify_UserLogoutT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_UserLogoutT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_UserLogout> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UserLogoutT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_UserLogoutBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account_uid(int32_t account_uid) {
    fbb_.AddElement<int32_t>(Notify_UserLogout::VT_ACCOUNT_UID, account_uid, 0);
  }
  Notify_UserLogoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_UserLogoutBuilder &operator=(const Notify_UserLogoutBuilder &);
  flatbuffers::Offset<Notify_UserLogout> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Notify_UserLogout>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_UserLogout> CreateNotify_UserLogout(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t account_uid = 0) {
  Notify_UserLogoutBuilder builder_(_fbb);
  builder_.add_account_uid(account_uid);
  return builder_.Finish();
}

flatbuffers::Offset<Notify_UserLogout> CreateNotify_UserLogout(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UserLogoutT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServerInfoT : public flatbuffers::NativeTable {
  typedef ServerInfo TableType;
  int32_t session_id;
  std::string name;
  int32_t type;
  ServerInfoT()
      : session_id(0),
        type(0) {
  }
};

struct ServerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerInfoT NativeTableType;
  enum {
    VT_SESSION_ID = 4,
    VT_NAME = 6,
    VT_TYPE = 8
  };
  int32_t session_id() const {
    return GetField<int32_t>(VT_SESSION_ID, 0);
  }
  bool mutate_session_id(int32_t _session_id) {
    return SetField<int32_t>(VT_SESSION_ID, _session_id, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SESSION_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
  ServerInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServerInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ServerInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServerInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_session_id(int32_t session_id) {
    fbb_.AddElement<int32_t>(ServerInfo::VT_SESSION_ID, session_id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ServerInfo::VT_NAME, name);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ServerInfo::VT_TYPE, type, 0);
  }
  ServerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerInfoBuilder &operator=(const ServerInfoBuilder &);
  flatbuffers::Offset<ServerInfo> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<ServerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerInfo> CreateServerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t session_id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t type = 0) {
  ServerInfoBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerInfo> CreateServerInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t session_id = 0,
    const char *name = nullptr,
    int32_t type = 0) {
  return ProtocolSS::CreateServerInfo(
      _fbb,
      session_id,
      name ? _fbb.CreateString(name) : 0,
      type);
}

flatbuffers::Offset<ServerInfo> CreateServerInfo(flatbuffers::FlatBufferBuilder &_fbb, const ServerInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_ServerListT : public flatbuffers::NativeTable {
  typedef Notify_ServerList TableType;
  std::vector<std::unique_ptr<ServerInfoT>> server_list;
  Notify_ServerListT() {
  }
};

struct Notify_ServerList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_ServerListT NativeTableType;
  enum {
    VT_SERVER_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ServerInfo>> *server_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ServerInfo>> *>(VT_SERVER_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<ServerInfo>> *mutable_server_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ServerInfo>> *>(VT_SERVER_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SERVER_LIST) &&
           verifier.Verify(server_list()) &&
           verifier.VerifyVectorOfTables(server_list()) &&
           verifier.EndTable();
  }
  Notify_ServerListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_ServerListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_ServerList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_ServerListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_ServerListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_server_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ServerInfo>>> server_list) {
    fbb_.AddOffset(Notify_ServerList::VT_SERVER_LIST, server_list);
  }
  Notify_ServerListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_ServerListBuilder &operator=(const Notify_ServerListBuilder &);
  flatbuffers::Offset<Notify_ServerList> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Notify_ServerList>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_ServerList> CreateNotify_ServerList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ServerInfo>>> server_list = 0) {
  Notify_ServerListBuilder builder_(_fbb);
  builder_.add_server_list(server_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notify_ServerList> CreateNotify_ServerListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ServerInfo>> *server_list = nullptr) {
  return ProtocolSS::CreateNotify_ServerList(
      _fbb,
      server_list ? _fbb.CreateVector<flatbuffers::Offset<ServerInfo>>(*server_list) : 0);
}

flatbuffers::Offset<Notify_ServerList> CreateNotify_ServerList(flatbuffers::FlatBufferBuilder &_fbb, const Notify_ServerListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RelayMessageT : public flatbuffers::NativeTable {
  typedef RelayMessage TableType;
  int32_t source_id;
  std::vector<int32_t> destinations_id;
  MessageTypeUnion message;
  RelayMessageT()
      : source_id(0) {
  }
};

struct RelayMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelayMessageT NativeTableType;
  enum {
    VT_SOURCE_ID = 4,
    VT_DESTINATIONS_ID = 6,
    VT_MESSAGE_TYPE = 8,
    VT_MESSAGE = 10
  };
  int32_t source_id() const {
    return GetField<int32_t>(VT_SOURCE_ID, 0);
  }
  bool mutate_source_id(int32_t _source_id) {
    return SetField<int32_t>(VT_SOURCE_ID, _source_id, 0);
  }
  const flatbuffers::Vector<int32_t> *destinations_id() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DESTINATIONS_ID);
  }
  flatbuffers::Vector<int32_t> *mutable_destinations_id() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_DESTINATIONS_ID);
  }
  MessageType message_type() const {
    return static_cast<MessageType>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  bool mutate_message_type(MessageType _message_type) {
    return SetField<uint8_t>(VT_MESSAGE_TYPE, static_cast<uint8_t>(_message_type), 0);
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const RelayMessage *message_as_RelayMessage() const {
    return message_type() == MessageType::RelayMessage ? static_cast<const RelayMessage *>(message()) : nullptr;
  }
  const ProtocolSS::TestMessage *message_as_TestMessage() const {
    return message_type() == MessageType::TestMessage ? static_cast<const ProtocolSS::TestMessage *>(message()) : nullptr;
  }
  const ProtocolSS::Notify_UnauthedAccess *message_as_Notify_UnauthedAccess() const {
    return message_type() == MessageType::Notify_UnauthedAccess ? static_cast<const ProtocolSS::Notify_UnauthedAccess *>(message()) : nullptr;
  }
  const ProtocolSS::Request_Login *message_as_Request_Login() const {
    return message_type() == MessageType::Request_Login ? static_cast<const ProtocolSS::Request_Login *>(message()) : nullptr;
  }
  const ProtocolSS::Reply_Login *message_as_Reply_Login() const {
    return message_type() == MessageType::Reply_Login ? static_cast<const ProtocolSS::Reply_Login *>(message()) : nullptr;
  }
  const ProtocolSS::Request_GenerateCredential *message_as_Request_GenerateCredential() const {
    return message_type() == MessageType::Request_GenerateCredential ? static_cast<const ProtocolSS::Request_GenerateCredential *>(message()) : nullptr;
  }
  const ProtocolSS::Reply_GenerateCredential *message_as_Reply_GenerateCredential() const {
    return message_type() == MessageType::Reply_GenerateCredential ? static_cast<const ProtocolSS::Reply_GenerateCredential *>(message()) : nullptr;
  }
  const ProtocolSS::Request_VerifyCredential *message_as_Request_VerifyCredential() const {
    return message_type() == MessageType::Request_VerifyCredential ? static_cast<const ProtocolSS::Request_VerifyCredential *>(message()) : nullptr;
  }
  const ProtocolSS::Reply_VerifyCredential *message_as_Reply_VerifyCredential() const {
    return message_type() == MessageType::Reply_VerifyCredential ? static_cast<const ProtocolSS::Reply_VerifyCredential *>(message()) : nullptr;
  }
  const ProtocolSS::Notify_UserLogout *message_as_Notify_UserLogout() const {
    return message_type() == MessageType::Notify_UserLogout ? static_cast<const ProtocolSS::Notify_UserLogout *>(message()) : nullptr;
  }
  const ProtocolSS::Notify_ServerList *message_as_Notify_ServerList() const {
    return message_type() == MessageType::Notify_ServerList ? static_cast<const ProtocolSS::Notify_ServerList *>(message()) : nullptr;
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SOURCE_ID) &&
           VerifyOffset(verifier, VT_DESTINATIONS_ID) &&
           verifier.Verify(destinations_id()) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessageType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
  RelayMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RelayMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RelayMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RelayMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const RelayMessage *RelayMessage::message_as<RelayMessage>() const {
  return message_as_RelayMessage();
}

template<> inline const ProtocolSS::TestMessage *RelayMessage::message_as<ProtocolSS::TestMessage>() const {
  return message_as_TestMessage();
}

template<> inline const ProtocolSS::Notify_UnauthedAccess *RelayMessage::message_as<ProtocolSS::Notify_UnauthedAccess>() const {
  return message_as_Notify_UnauthedAccess();
}

template<> inline const ProtocolSS::Request_Login *RelayMessage::message_as<ProtocolSS::Request_Login>() const {
  return message_as_Request_Login();
}

template<> inline const ProtocolSS::Reply_Login *RelayMessage::message_as<ProtocolSS::Reply_Login>() const {
  return message_as_Reply_Login();
}

template<> inline const ProtocolSS::Request_GenerateCredential *RelayMessage::message_as<ProtocolSS::Request_GenerateCredential>() const {
  return message_as_Request_GenerateCredential();
}

template<> inline const ProtocolSS::Reply_GenerateCredential *RelayMessage::message_as<ProtocolSS::Reply_GenerateCredential>() const {
  return message_as_Reply_GenerateCredential();
}

template<> inline const ProtocolSS::Request_VerifyCredential *RelayMessage::message_as<ProtocolSS::Request_VerifyCredential>() const {
  return message_as_Request_VerifyCredential();
}

template<> inline const ProtocolSS::Reply_VerifyCredential *RelayMessage::message_as<ProtocolSS::Reply_VerifyCredential>() const {
  return message_as_Reply_VerifyCredential();
}

template<> inline const ProtocolSS::Notify_UserLogout *RelayMessage::message_as<ProtocolSS::Notify_UserLogout>() const {
  return message_as_Notify_UserLogout();
}

template<> inline const ProtocolSS::Notify_ServerList *RelayMessage::message_as<ProtocolSS::Notify_ServerList>() const {
  return message_as_Notify_ServerList();
}

struct RelayMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_source_id(int32_t source_id) {
    fbb_.AddElement<int32_t>(RelayMessage::VT_SOURCE_ID, source_id, 0);
  }
  void add_destinations_id(flatbuffers::Offset<flatbuffers::Vector<int32_t>> destinations_id) {
    fbb_.AddOffset(RelayMessage::VT_DESTINATIONS_ID, destinations_id);
  }
  void add_message_type(MessageType message_type) {
    fbb_.AddElement<uint8_t>(RelayMessage::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(RelayMessage::VT_MESSAGE, message);
  }
  RelayMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelayMessageBuilder &operator=(const RelayMessageBuilder &);
  flatbuffers::Offset<RelayMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<RelayMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<RelayMessage> CreateRelayMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t source_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> destinations_id = 0,
    MessageType message_type = MessageType::NONE,
    flatbuffers::Offset<void> message = 0) {
  RelayMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_destinations_id(destinations_id);
  builder_.add_source_id(source_id);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RelayMessage> CreateRelayMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t source_id = 0,
    const std::vector<int32_t> *destinations_id = nullptr,
    MessageType message_type = MessageType::NONE,
    flatbuffers::Offset<void> message = 0) {
  return ProtocolSS::CreateRelayMessage(
      _fbb,
      source_id,
      destinations_id ? _fbb.CreateVector<int32_t>(*destinations_id) : 0,
      message_type,
      message);
}

flatbuffers::Offset<RelayMessage> CreateRelayMessage(flatbuffers::FlatBufferBuilder &_fbb, const RelayMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MessageRootT : public flatbuffers::NativeTable {
  typedef MessageRoot TableType;
  MessageTypeUnion message;
  MessageRootT() {
  }
};

struct MessageRoot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageRootT NativeTableType;
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  MessageType message_type() const {
    return static_cast<MessageType>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  bool mutate_message_type(MessageType _message_type) {
    return SetField<uint8_t>(VT_MESSAGE_TYPE, static_cast<uint8_t>(_message_type), 0);
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const RelayMessage *message_as_RelayMessage() const {
    return message_type() == MessageType::RelayMessage ? static_cast<const RelayMessage *>(message()) : nullptr;
  }
  const ProtocolSS::TestMessage *message_as_TestMessage() const {
    return message_type() == MessageType::TestMessage ? static_cast<const ProtocolSS::TestMessage *>(message()) : nullptr;
  }
  const ProtocolSS::Notify_UnauthedAccess *message_as_Notify_UnauthedAccess() const {
    return message_type() == MessageType::Notify_UnauthedAccess ? static_cast<const ProtocolSS::Notify_UnauthedAccess *>(message()) : nullptr;
  }
  const ProtocolSS::Request_Login *message_as_Request_Login() const {
    return message_type() == MessageType::Request_Login ? static_cast<const ProtocolSS::Request_Login *>(message()) : nullptr;
  }
  const ProtocolSS::Reply_Login *message_as_Reply_Login() const {
    return message_type() == MessageType::Reply_Login ? static_cast<const ProtocolSS::Reply_Login *>(message()) : nullptr;
  }
  const ProtocolSS::Request_GenerateCredential *message_as_Request_GenerateCredential() const {
    return message_type() == MessageType::Request_GenerateCredential ? static_cast<const ProtocolSS::Request_GenerateCredential *>(message()) : nullptr;
  }
  const ProtocolSS::Reply_GenerateCredential *message_as_Reply_GenerateCredential() const {
    return message_type() == MessageType::Reply_GenerateCredential ? static_cast<const ProtocolSS::Reply_GenerateCredential *>(message()) : nullptr;
  }
  const ProtocolSS::Request_VerifyCredential *message_as_Request_VerifyCredential() const {
    return message_type() == MessageType::Request_VerifyCredential ? static_cast<const ProtocolSS::Request_VerifyCredential *>(message()) : nullptr;
  }
  const ProtocolSS::Reply_VerifyCredential *message_as_Reply_VerifyCredential() const {
    return message_type() == MessageType::Reply_VerifyCredential ? static_cast<const ProtocolSS::Reply_VerifyCredential *>(message()) : nullptr;
  }
  const ProtocolSS::Notify_UserLogout *message_as_Notify_UserLogout() const {
    return message_type() == MessageType::Notify_UserLogout ? static_cast<const ProtocolSS::Notify_UserLogout *>(message()) : nullptr;
  }
  const ProtocolSS::Notify_ServerList *message_as_Notify_ServerList() const {
    return message_type() == MessageType::Notify_ServerList ? static_cast<const ProtocolSS::Notify_ServerList *>(message()) : nullptr;
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessageType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
  MessageRootT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageRootT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MessageRoot> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageRootT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const RelayMessage *MessageRoot::message_as<RelayMessage>() const {
  return message_as_RelayMessage();
}

template<> inline const ProtocolSS::TestMessage *MessageRoot::message_as<ProtocolSS::TestMessage>() const {
  return message_as_TestMessage();
}

template<> inline const ProtocolSS::Notify_UnauthedAccess *MessageRoot::message_as<ProtocolSS::Notify_UnauthedAccess>() const {
  return message_as_Notify_UnauthedAccess();
}

template<> inline const ProtocolSS::Request_Login *MessageRoot::message_as<ProtocolSS::Request_Login>() const {
  return message_as_Request_Login();
}

template<> inline const ProtocolSS::Reply_Login *MessageRoot::message_as<ProtocolSS::Reply_Login>() const {
  return message_as_Reply_Login();
}

template<> inline const ProtocolSS::Request_GenerateCredential *MessageRoot::message_as<ProtocolSS::Request_GenerateCredential>() const {
  return message_as_Request_GenerateCredential();
}

template<> inline const ProtocolSS::Reply_GenerateCredential *MessageRoot::message_as<ProtocolSS::Reply_GenerateCredential>() const {
  return message_as_Reply_GenerateCredential();
}

template<> inline const ProtocolSS::Request_VerifyCredential *MessageRoot::message_as<ProtocolSS::Request_VerifyCredential>() const {
  return message_as_Request_VerifyCredential();
}

template<> inline const ProtocolSS::Reply_VerifyCredential *MessageRoot::message_as<ProtocolSS::Reply_VerifyCredential>() const {
  return message_as_Reply_VerifyCredential();
}

template<> inline const ProtocolSS::Notify_UserLogout *MessageRoot::message_as<ProtocolSS::Notify_UserLogout>() const {
  return message_as_Notify_UserLogout();
}

template<> inline const ProtocolSS::Notify_ServerList *MessageRoot::message_as<ProtocolSS::Notify_ServerList>() const {
  return message_as_Notify_ServerList();
}

struct MessageRootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(MessageType message_type) {
    fbb_.AddElement<uint8_t>(MessageRoot::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(MessageRoot::VT_MESSAGE, message);
  }
  MessageRootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageRootBuilder &operator=(const MessageRootBuilder &);
  flatbuffers::Offset<MessageRoot> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<MessageRoot>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageRoot> CreateMessageRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    MessageType message_type = MessageType::NONE,
    flatbuffers::Offset<void> message = 0) {
  MessageRootBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

flatbuffers::Offset<MessageRoot> CreateMessageRoot(flatbuffers::FlatBufferBuilder &_fbb, const MessageRootT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TestMessageT *TestMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TestMessageT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TestMessage::UnPackTo(TestMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = str_msg(); if (_e) _o->str_msg = _e->str(); };
}

inline flatbuffers::Offset<TestMessage> TestMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TestMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTestMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TestMessage> CreateTestMessage(flatbuffers::FlatBufferBuilder &_fbb, const TestMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _str_msg = _o->str_msg.size() ? _fbb.CreateString(_o->str_msg) : 0;
  return ProtocolSS::CreateTestMessage(
      _fbb,
      _str_msg);
}

inline Notify_UnauthedAccessT *Notify_UnauthedAccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_UnauthedAccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_UnauthedAccess::UnPackTo(Notify_UnauthedAccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Notify_UnauthedAccess> Notify_UnauthedAccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_UnauthedAccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_UnauthedAccess> CreateNotify_UnauthedAccess(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return ProtocolSS::CreateNotify_UnauthedAccess(
      _fbb);
}

inline Request_LoginT *Request_Login::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_LoginT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_Login::UnPackTo(Request_LoginT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = client_name(); if (_e) _o->client_name = _e->str(); };
  { auto _e = client_type(); _o->client_type = _e; };
}

inline flatbuffers::Offset<Request_Login> Request_Login::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Login(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Login> CreateRequest_Login(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _client_name = _o->client_name.size() ? _fbb.CreateString(_o->client_name) : 0;
  auto _client_type = _o->client_type;
  return ProtocolSS::CreateRequest_Login(
      _fbb,
      _client_name,
      _client_type);
}

inline Reply_LoginT *Reply_Login::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_LoginT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_Login::UnPackTo(Reply_LoginT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
  { auto _e = session_id(); _o->session_id = _e; };
}

inline flatbuffers::Offset<Reply_Login> Reply_Login::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_Login(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_Login> CreateReply_Login(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  auto _session_id = _o->session_id;
  return ProtocolSS::CreateReply_Login(
      _fbb,
      _error_code,
      _session_id);
}

inline Request_GenerateCredentialT *Request_GenerateCredential::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_GenerateCredentialT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_GenerateCredential::UnPackTo(Request_GenerateCredentialT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = session_id(); _o->session_id = _e; };
  { auto _e = account_uid(); _o->account_uid = _e; };
}

inline flatbuffers::Offset<Request_GenerateCredential> Request_GenerateCredential::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_GenerateCredentialT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_GenerateCredential(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_GenerateCredential> CreateRequest_GenerateCredential(flatbuffers::FlatBufferBuilder &_fbb, const Request_GenerateCredentialT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _session_id = _o->session_id;
  auto _account_uid = _o->account_uid;
  return ProtocolSS::CreateRequest_GenerateCredential(
      _fbb,
      _session_id,
      _account_uid);
}

inline Reply_GenerateCredentialT *Reply_GenerateCredential::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_GenerateCredentialT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_GenerateCredential::UnPackTo(Reply_GenerateCredentialT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = session_id(); _o->session_id = _e; };
  { auto _e = credential(); if (_e) _o->credential = _e->str(); };
}

inline flatbuffers::Offset<Reply_GenerateCredential> Reply_GenerateCredential::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_GenerateCredentialT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_GenerateCredential(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_GenerateCredential> CreateReply_GenerateCredential(flatbuffers::FlatBufferBuilder &_fbb, const Reply_GenerateCredentialT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _session_id = _o->session_id;
  auto _credential = _o->credential.size() ? _fbb.CreateString(_o->credential) : 0;
  return ProtocolSS::CreateReply_GenerateCredential(
      _fbb,
      _session_id,
      _credential);
}

inline Request_VerifyCredentialT *Request_VerifyCredential::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_VerifyCredentialT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_VerifyCredential::UnPackTo(Request_VerifyCredentialT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = session_id(); _o->session_id = _e; };
  { auto _e = credential(); if (_e) _o->credential = _e->str(); };
}

inline flatbuffers::Offset<Request_VerifyCredential> Request_VerifyCredential::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_VerifyCredentialT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_VerifyCredential(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_VerifyCredential> CreateRequest_VerifyCredential(flatbuffers::FlatBufferBuilder &_fbb, const Request_VerifyCredentialT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _session_id = _o->session_id;
  auto _credential = _o->credential.size() ? _fbb.CreateString(_o->credential) : 0;
  return ProtocolSS::CreateRequest_VerifyCredential(
      _fbb,
      _session_id,
      _credential);
}

inline Reply_VerifyCredentialT *Reply_VerifyCredential::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_VerifyCredentialT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_VerifyCredential::UnPackTo(Reply_VerifyCredentialT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
  { auto _e = session_id(); _o->session_id = _e; };
  { auto _e = credential(); if (_e) _o->credential = _e->str(); };
  { auto _e = account_uid(); _o->account_uid = _e; };
}

inline flatbuffers::Offset<Reply_VerifyCredential> Reply_VerifyCredential::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_VerifyCredentialT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_VerifyCredential(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_VerifyCredential> CreateReply_VerifyCredential(flatbuffers::FlatBufferBuilder &_fbb, const Reply_VerifyCredentialT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  auto _session_id = _o->session_id;
  auto _credential = _o->credential.size() ? _fbb.CreateString(_o->credential) : 0;
  auto _account_uid = _o->account_uid;
  return ProtocolSS::CreateReply_VerifyCredential(
      _fbb,
      _error_code,
      _session_id,
      _credential,
      _account_uid);
}

inline Notify_UserLogoutT *Notify_UserLogout::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_UserLogoutT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_UserLogout::UnPackTo(Notify_UserLogoutT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = account_uid(); _o->account_uid = _e; };
}

inline flatbuffers::Offset<Notify_UserLogout> Notify_UserLogout::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UserLogoutT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_UserLogout(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_UserLogout> CreateNotify_UserLogout(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UserLogoutT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _account_uid = _o->account_uid;
  return ProtocolSS::CreateNotify_UserLogout(
      _fbb,
      _account_uid);
}

inline ServerInfoT *ServerInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ServerInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ServerInfo::UnPackTo(ServerInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = session_id(); _o->session_id = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = type(); _o->type = _e; };
}

inline flatbuffers::Offset<ServerInfo> ServerInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateServerInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ServerInfo> CreateServerInfo(flatbuffers::FlatBufferBuilder &_fbb, const ServerInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _session_id = _o->session_id;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _type = _o->type;
  return ProtocolSS::CreateServerInfo(
      _fbb,
      _session_id,
      _name,
      _type);
}

inline Notify_ServerListT *Notify_ServerList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_ServerListT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_ServerList::UnPackTo(Notify_ServerListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = server_list(); if (_e) { _o->server_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->server_list[_i] = std::unique_ptr<ServerInfoT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Notify_ServerList> Notify_ServerList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_ServerListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_ServerList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_ServerList> CreateNotify_ServerList(flatbuffers::FlatBufferBuilder &_fbb, const Notify_ServerListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _server_list = _o->server_list.size() ? _fbb.CreateVector<flatbuffers::Offset<ServerInfo>>(_o->server_list.size(), [&](size_t i) { return CreateServerInfo(_fbb, _o->server_list[i].get(), _rehasher); }) : 0;
  return ProtocolSS::CreateNotify_ServerList(
      _fbb,
      _server_list);
}

inline RelayMessageT *RelayMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RelayMessageT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RelayMessage::UnPackTo(RelayMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = source_id(); _o->source_id = _e; };
  { auto _e = destinations_id(); if (_e) { _o->destinations_id.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->destinations_id[_i] = _e->Get(_i); } } };
  { auto _e = message_type(); _o->message.type = _e; };
  { auto _e = message(); if (_e) _o->message.value = MessageTypeUnion::UnPack(_e, message_type(), _resolver); };
}

inline flatbuffers::Offset<RelayMessage> RelayMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RelayMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelayMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RelayMessage> CreateRelayMessage(flatbuffers::FlatBufferBuilder &_fbb, const RelayMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _source_id = _o->source_id;
  auto _destinations_id = _o->destinations_id.size() ? _fbb.CreateVector(_o->destinations_id) : 0;
  auto _message_type = _o->message.type;
  auto _message = _o->message.Pack(_fbb);
  return ProtocolSS::CreateRelayMessage(
      _fbb,
      _source_id,
      _destinations_id,
      _message_type,
      _message);
}

inline MessageRootT *MessageRoot::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MessageRootT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MessageRoot::UnPackTo(MessageRootT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message_type(); _o->message.type = _e; };
  { auto _e = message(); if (_e) _o->message.value = MessageTypeUnion::UnPack(_e, message_type(), _resolver); };
}

inline flatbuffers::Offset<MessageRoot> MessageRoot::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageRootT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessageRoot(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MessageRoot> CreateMessageRoot(flatbuffers::FlatBufferBuilder &_fbb, const MessageRootT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _message_type = _o->message.type;
  auto _message = _o->message.Pack(_fbb);
  return ProtocolSS::CreateMessageRoot(
      _fbb,
      _message_type,
      _message);
}

inline bool VerifyMessageType(flatbuffers::Verifier &verifier, const void *obj, MessageType type) {
  switch (type) {
    case MessageType::NONE: {
      return true;
    }
    case MessageType::RelayMessage: {
      auto ptr = reinterpret_cast<const RelayMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::TestMessage: {
      auto ptr = reinterpret_cast<const ProtocolSS::TestMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<const ProtocolSS::Notify_UnauthedAccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Request_Login: {
      auto ptr = reinterpret_cast<const ProtocolSS::Request_Login *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Reply_Login: {
      auto ptr = reinterpret_cast<const ProtocolSS::Reply_Login *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Request_GenerateCredential: {
      auto ptr = reinterpret_cast<const ProtocolSS::Request_GenerateCredential *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Reply_GenerateCredential: {
      auto ptr = reinterpret_cast<const ProtocolSS::Reply_GenerateCredential *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Request_VerifyCredential: {
      auto ptr = reinterpret_cast<const ProtocolSS::Request_VerifyCredential *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Reply_VerifyCredential: {
      auto ptr = reinterpret_cast<const ProtocolSS::Reply_VerifyCredential *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Notify_UserLogout: {
      auto ptr = reinterpret_cast<const ProtocolSS::Notify_UserLogout *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Notify_ServerList: {
      auto ptr = reinterpret_cast<const ProtocolSS::Notify_ServerList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageType(
        verifier,  values->Get(i), types->GetEnum<MessageType>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MessageTypeUnion::UnPack(const void *obj, MessageType type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case MessageType::RelayMessage: {
      auto ptr = reinterpret_cast<const RelayMessage *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::TestMessage: {
      auto ptr = reinterpret_cast<const ProtocolSS::TestMessage *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<const ProtocolSS::Notify_UnauthedAccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Request_Login: {
      auto ptr = reinterpret_cast<const ProtocolSS::Request_Login *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Reply_Login: {
      auto ptr = reinterpret_cast<const ProtocolSS::Reply_Login *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Request_GenerateCredential: {
      auto ptr = reinterpret_cast<const ProtocolSS::Request_GenerateCredential *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Reply_GenerateCredential: {
      auto ptr = reinterpret_cast<const ProtocolSS::Reply_GenerateCredential *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Request_VerifyCredential: {
      auto ptr = reinterpret_cast<const ProtocolSS::Request_VerifyCredential *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Reply_VerifyCredential: {
      auto ptr = reinterpret_cast<const ProtocolSS::Reply_VerifyCredential *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Notify_UserLogout: {
      auto ptr = reinterpret_cast<const ProtocolSS::Notify_UserLogout *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Notify_ServerList: {
      auto ptr = reinterpret_cast<const ProtocolSS::Notify_ServerList *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MessageTypeUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case MessageType::RelayMessage: {
      auto ptr = reinterpret_cast<const RelayMessageT *>(value);
      return CreateRelayMessage(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::TestMessage: {
      auto ptr = reinterpret_cast<const ProtocolSS::TestMessageT *>(value);
      return CreateTestMessage(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<const ProtocolSS::Notify_UnauthedAccessT *>(value);
      return CreateNotify_UnauthedAccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Request_Login: {
      auto ptr = reinterpret_cast<const ProtocolSS::Request_LoginT *>(value);
      return CreateRequest_Login(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Reply_Login: {
      auto ptr = reinterpret_cast<const ProtocolSS::Reply_LoginT *>(value);
      return CreateReply_Login(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Request_GenerateCredential: {
      auto ptr = reinterpret_cast<const ProtocolSS::Request_GenerateCredentialT *>(value);
      return CreateRequest_GenerateCredential(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Reply_GenerateCredential: {
      auto ptr = reinterpret_cast<const ProtocolSS::Reply_GenerateCredentialT *>(value);
      return CreateReply_GenerateCredential(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Request_VerifyCredential: {
      auto ptr = reinterpret_cast<const ProtocolSS::Request_VerifyCredentialT *>(value);
      return CreateRequest_VerifyCredential(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Reply_VerifyCredential: {
      auto ptr = reinterpret_cast<const ProtocolSS::Reply_VerifyCredentialT *>(value);
      return CreateReply_VerifyCredential(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Notify_UserLogout: {
      auto ptr = reinterpret_cast<const ProtocolSS::Notify_UserLogoutT *>(value);
      return CreateNotify_UserLogout(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Notify_ServerList: {
      auto ptr = reinterpret_cast<const ProtocolSS::Notify_ServerListT *>(value);
      return CreateNotify_ServerList(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MessageTypeUnion::MessageTypeUnion(const MessageTypeUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case MessageType::RelayMessage: {
      value = new RelayMessageT(*reinterpret_cast<RelayMessageT *>(u.value));
      break;
    }
    case MessageType::TestMessage: {
      value = new ProtocolSS::TestMessageT(*reinterpret_cast<ProtocolSS::TestMessageT *>(u.value));
      break;
    }
    case MessageType::Notify_UnauthedAccess: {
      value = new ProtocolSS::Notify_UnauthedAccessT(*reinterpret_cast<ProtocolSS::Notify_UnauthedAccessT *>(u.value));
      break;
    }
    case MessageType::Request_Login: {
      value = new ProtocolSS::Request_LoginT(*reinterpret_cast<ProtocolSS::Request_LoginT *>(u.value));
      break;
    }
    case MessageType::Reply_Login: {
      value = new ProtocolSS::Reply_LoginT(*reinterpret_cast<ProtocolSS::Reply_LoginT *>(u.value));
      break;
    }
    case MessageType::Request_GenerateCredential: {
      value = new ProtocolSS::Request_GenerateCredentialT(*reinterpret_cast<ProtocolSS::Request_GenerateCredentialT *>(u.value));
      break;
    }
    case MessageType::Reply_GenerateCredential: {
      value = new ProtocolSS::Reply_GenerateCredentialT(*reinterpret_cast<ProtocolSS::Reply_GenerateCredentialT *>(u.value));
      break;
    }
    case MessageType::Request_VerifyCredential: {
      value = new ProtocolSS::Request_VerifyCredentialT(*reinterpret_cast<ProtocolSS::Request_VerifyCredentialT *>(u.value));
      break;
    }
    case MessageType::Reply_VerifyCredential: {
      value = new ProtocolSS::Reply_VerifyCredentialT(*reinterpret_cast<ProtocolSS::Reply_VerifyCredentialT *>(u.value));
      break;
    }
    case MessageType::Notify_UserLogout: {
      value = new ProtocolSS::Notify_UserLogoutT(*reinterpret_cast<ProtocolSS::Notify_UserLogoutT *>(u.value));
      break;
    }
    case MessageType::Notify_ServerList: {
      assert(false);  // ProtocolSS::Notify_ServerListT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void MessageTypeUnion::Reset() {
  switch (type) {
    case MessageType::RelayMessage: {
      auto ptr = reinterpret_cast<RelayMessageT *>(value);
      delete ptr;
      break;
    }
    case MessageType::TestMessage: {
      auto ptr = reinterpret_cast<ProtocolSS::TestMessageT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<ProtocolSS::Notify_UnauthedAccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Request_Login: {
      auto ptr = reinterpret_cast<ProtocolSS::Request_LoginT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Reply_Login: {
      auto ptr = reinterpret_cast<ProtocolSS::Reply_LoginT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Request_GenerateCredential: {
      auto ptr = reinterpret_cast<ProtocolSS::Request_GenerateCredentialT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Reply_GenerateCredential: {
      auto ptr = reinterpret_cast<ProtocolSS::Reply_GenerateCredentialT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Request_VerifyCredential: {
      auto ptr = reinterpret_cast<ProtocolSS::Request_VerifyCredentialT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Reply_VerifyCredential: {
      auto ptr = reinterpret_cast<ProtocolSS::Reply_VerifyCredentialT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Notify_UserLogout: {
      auto ptr = reinterpret_cast<ProtocolSS::Notify_UserLogoutT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Notify_ServerList: {
      auto ptr = reinterpret_cast<ProtocolSS::Notify_ServerListT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = MessageType::NONE;
}

inline const ProtocolSS::MessageRoot *GetMessageRoot(const void *buf) {
  return flatbuffers::GetRoot<ProtocolSS::MessageRoot>(buf);
}

inline MessageRoot *GetMutableMessageRoot(void *buf) {
  return flatbuffers::GetMutableRoot<MessageRoot>(buf);
}

inline const char *MessageRootIdentifier() {
  return "PTSS";
}

inline bool MessageRootBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MessageRootIdentifier());
}

inline bool VerifyMessageRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ProtocolSS::MessageRoot>(MessageRootIdentifier());
}

inline void FinishMessageRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ProtocolSS::MessageRoot> root) {
  fbb.Finish(root, MessageRootIdentifier());
}

inline std::unique_ptr<MessageRootT> UnPackMessageRoot(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<MessageRootT>(GetMessageRoot(buf)->UnPack(res));
}

}  // namespace ProtocolSS

#endif  // FLATBUFFERS_GENERATED_PROTOCOLSS_PROTOCOLSS_H_
