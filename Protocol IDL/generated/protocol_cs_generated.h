// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTOCOLCS_PROTOCOLCS_H_
#define FLATBUFFERS_GENERATED_PROTOCOLCS_PROTOCOLCS_H_

#include "flatbuffers/flatbuffers.h"

namespace ProtocolCS {

struct Vec2;

struct Vec3;

struct Notify_UnauthedAccess;
struct Notify_UnauthedAccessT;

namespace Login {

struct Hero;
struct HeroT;

struct Request_Login;
struct Request_LoginT;

struct Reply_LoginSuccess;
struct Reply_LoginSuccessT;

struct Reply_LoginFailed;
struct Reply_LoginFailedT;

struct Request_Join;
struct Request_JoinT;

struct Reply_JoinSuccess;
struct Reply_JoinSuccessT;

struct Reply_JoinFailed;
struct Reply_JoinFailedT;

struct Request_HeroList;
struct Request_HeroListT;

struct Reply_HeroList;
struct Reply_HeroListT;

struct Request_CreateHero;
struct Request_CreateHeroT;

struct Reply_CreateHeroSuccess;
struct Reply_CreateHeroSuccessT;

struct Reply_CreateHeroFailed;
struct Reply_CreateHeroFailedT;

struct Request_DeleteHero;
struct Request_DeleteHeroT;

struct Reply_DeleteHeroSuccess;
struct Reply_DeleteHeroSuccessT;

struct Reply_DeleteHeroFailed;
struct Reply_DeleteHeroFailedT;

}  // namespace Login

namespace World {

struct Hero;
struct HeroT;

struct Monster;
struct MonsterT;

struct GateInfo;
struct GateInfoT;

struct MapData;
struct MapDataT;

struct Actor;
struct ActorT;

struct MoveActionInfo;
struct MoveActionInfoT;

struct SkillActionInfo;
struct SkillActionInfoT;

struct DamageInfo;
struct DamageInfoT;

struct StateInfo;
struct StateInfoT;

struct AttributeInfo;
struct AttributeInfoT;

struct Request_Login;
struct Request_LoginT;

struct Reply_LoginSuccess;
struct Reply_LoginSuccessT;

struct Reply_LoginFailed;
struct Reply_LoginFailedT;

struct Notify_LoadFinish;
struct Notify_LoadFinishT;

struct Notify_EnterSuccess;
struct Notify_EnterSuccessT;

struct Notify_EnterFailed;
struct Notify_EnterFailedT;

struct Request_ActionMove;
struct Request_ActionMoveT;

struct Request_ActionSkill;
struct Request_ActionSkillT;

struct Request_Respawn;
struct Request_RespawnT;

struct Notify_Appear;
struct Notify_AppearT;

struct Notify_Disappear;
struct Notify_DisappearT;

struct Notify_Update;
struct Notify_UpdateT;

struct Request_EnterGate;
struct Request_EnterGateT;

struct Reply_EnterGateFailed;
struct Reply_EnterGateFailedT;

}  // namespace World

struct MessageRoot;
struct MessageRootT;

enum class ErrorCode : int32_t {
  OK = 0,
  UNEXPECTED = 1,
  DATABASE_FAILED = 2,
  INVALID_SESSION = 10,
  INVALID_STRING = 20,
  LOGIN_INCORRECT_ACC_NAME = 100,
  LOGIN_INCORRECT_ACC_PASSWORD = 101,
  LOGIN_DUPLICATION = 102,
  JOIN_ACC_NAME_ALREADY = 103,
  JOIN_CANNOT_ACC_CREATE = 104,
  CREATE_HERO_NAME_ALREADY = 105,
  CREATE_HERO_CANNOT_CREATE = 106,
  CREATE_HERO_ATTRIBUTE_NOT_EXIST = 107,
  DELETE_HERO_NOT_EXIST = 108,
  DELETE_HERO_CANNOT_DELETE = 109,
  WORLD_LOGIN_INVALID_CREDENTIAL = 200,
  WORLD_LOGIN_INVALID_ACCOUNT = 201,
  WORLD_LOGIN_INVALID_HERO = 202,
  WORLD_LOGIN_INVALID_STATE = 203,
  WORLD_CANNOT_ENTER_ZONE = 204,
  WORLD_NEXT_INVALID_STATE = 205,
  WORLD_CANNOT_LOAD_HERO = 206,
  WORLD_CANNOT_FIND_ZONE = 207,
  WORLD_CANNOT_FIND_GATE = 208,
  WORLD_INVALID_HERO = 209,
  MIN = OK,
  MAX = WORLD_INVALID_HERO
};

enum class ClassType : int32_t {
  NONE = 0,
  Knight = 1,
  Archer = 2,
  Mage = 3,
  MIN = NONE,
  MAX = Mage
};

inline const char **EnumNamesClassType() {
  static const char *names[] = {
    "NONE",
    "Knight",
    "Archer",
    "Mage",
    nullptr
  };
  return names;
}

inline const char *EnumNameClassType(ClassType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesClassType()[index];
}

enum class MapType : int32_t {
  NONE = 0,
  FIELD = 1,
  DUNGEON = 2,
  MIN = NONE,
  MAX = DUNGEON
};

inline const char **EnumNamesMapType() {
  static const char *names[] = {
    "NONE",
    "FIELD",
    "DUNGEON",
    nullptr
  };
  return names;
}

inline const char *EnumNameMapType(MapType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMapType()[index];
}

namespace World {

enum class ActorType : uint8_t {
  NONE = 0,
  Hero = 1,
  Monster = 2,
  MIN = NONE,
  MAX = Monster
};

inline const char **EnumNamesActorType() {
  static const char *names[] = {
    "NONE",
    "Hero",
    "Monster",
    nullptr
  };
  return names;
}

inline const char *EnumNameActorType(ActorType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesActorType()[index];
}

template<typename T> struct ActorTypeTraits {
  static const ActorType enum_value = ActorType::NONE;
};

template<> struct ActorTypeTraits<Hero> {
  static const ActorType enum_value = ActorType::Hero;
};

template<> struct ActorTypeTraits<Monster> {
  static const ActorType enum_value = ActorType::Monster;
};

struct ActorTypeUnion {
  ActorType type;
  void *value;

  ActorTypeUnion() : type(ActorType::NONE), value(nullptr) {}
  ActorTypeUnion(ActorTypeUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ActorType::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ActorTypeUnion(const ActorTypeUnion &) FLATBUFFERS_NOEXCEPT;
  ActorTypeUnion &operator=(const ActorTypeUnion &u) FLATBUFFERS_NOEXCEPT
    { ActorTypeUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ActorTypeUnion &operator=(ActorTypeUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ActorTypeUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    Reset();
    type = ActorTypeTraits<typename T::TableType>::enum_value;
    if (type != ActorType::NONE) {
      value = new T(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ActorType type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  HeroT *AsHero() {
    return type == ActorType::Hero ?
      reinterpret_cast<HeroT *>(value) : nullptr;
  }
  MonsterT *AsMonster() {
    return type == ActorType::Monster ?
      reinterpret_cast<MonsterT *>(value) : nullptr;
  }
};

bool VerifyActorType(flatbuffers::Verifier &verifier, const void *obj, ActorType type);
bool VerifyActorTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class StateType : int32_t {
  NONE = 0,
  Alive = 1,
  Jump = 2,
  Dead = 3,
  MIN = NONE,
  MAX = Dead
};

inline const char **EnumNamesStateType() {
  static const char *names[] = {
    "NONE",
    "Alive",
    "Jump",
    "Dead",
    nullptr
  };
  return names;
}

inline const char *EnumNameStateType(StateType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesStateType()[index];
}

enum class UpdateType : uint8_t {
  NONE = 0,
  Actor = 1,
  MoveActionInfo = 2,
  SkillActionInfo = 3,
  DamageInfo = 4,
  StateInfo = 5,
  AttributeInfo = 6,
  MIN = NONE,
  MAX = AttributeInfo
};

inline const char **EnumNamesUpdateType() {
  static const char *names[] = {
    "NONE",
    "Actor",
    "MoveActionInfo",
    "SkillActionInfo",
    "DamageInfo",
    "StateInfo",
    "AttributeInfo",
    nullptr
  };
  return names;
}

inline const char *EnumNameUpdateType(UpdateType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesUpdateType()[index];
}

template<typename T> struct UpdateTypeTraits {
  static const UpdateType enum_value = UpdateType::NONE;
};

template<> struct UpdateTypeTraits<Actor> {
  static const UpdateType enum_value = UpdateType::Actor;
};

template<> struct UpdateTypeTraits<MoveActionInfo> {
  static const UpdateType enum_value = UpdateType::MoveActionInfo;
};

template<> struct UpdateTypeTraits<SkillActionInfo> {
  static const UpdateType enum_value = UpdateType::SkillActionInfo;
};

template<> struct UpdateTypeTraits<DamageInfo> {
  static const UpdateType enum_value = UpdateType::DamageInfo;
};

template<> struct UpdateTypeTraits<StateInfo> {
  static const UpdateType enum_value = UpdateType::StateInfo;
};

template<> struct UpdateTypeTraits<AttributeInfo> {
  static const UpdateType enum_value = UpdateType::AttributeInfo;
};

struct UpdateTypeUnion {
  UpdateType type;
  void *value;

  UpdateTypeUnion() : type(UpdateType::NONE), value(nullptr) {}
  UpdateTypeUnion(UpdateTypeUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(UpdateType::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  UpdateTypeUnion(const UpdateTypeUnion &) FLATBUFFERS_NOEXCEPT;
  UpdateTypeUnion &operator=(const UpdateTypeUnion &u) FLATBUFFERS_NOEXCEPT
    { UpdateTypeUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  UpdateTypeUnion &operator=(UpdateTypeUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~UpdateTypeUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    Reset();
    type = UpdateTypeTraits<typename T::TableType>::enum_value;
    if (type != UpdateType::NONE) {
      value = new T(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, UpdateType type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ActorT *AsActor() {
    return type == UpdateType::Actor ?
      reinterpret_cast<ActorT *>(value) : nullptr;
  }
  MoveActionInfoT *AsMoveActionInfo() {
    return type == UpdateType::MoveActionInfo ?
      reinterpret_cast<MoveActionInfoT *>(value) : nullptr;
  }
  SkillActionInfoT *AsSkillActionInfo() {
    return type == UpdateType::SkillActionInfo ?
      reinterpret_cast<SkillActionInfoT *>(value) : nullptr;
  }
  DamageInfoT *AsDamageInfo() {
    return type == UpdateType::DamageInfo ?
      reinterpret_cast<DamageInfoT *>(value) : nullptr;
  }
  StateInfoT *AsStateInfo() {
    return type == UpdateType::StateInfo ?
      reinterpret_cast<StateInfoT *>(value) : nullptr;
  }
  AttributeInfoT *AsAttributeInfo() {
    return type == UpdateType::AttributeInfo ?
      reinterpret_cast<AttributeInfoT *>(value) : nullptr;
  }
};

bool VerifyUpdateType(flatbuffers::Verifier &verifier, const void *obj, UpdateType type);
bool VerifyUpdateTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

}  // namespace World

enum class MessageType : uint8_t {
  NONE = 0,
  Notify_UnauthedAccess = 1,
  Login_Request_Login = 2,
  Login_Reply_LoginSuccess = 3,
  Login_Reply_LoginFailed = 4,
  Login_Request_Join = 5,
  Login_Reply_JoinSuccess = 6,
  Login_Reply_JoinFailed = 7,
  Login_Request_HeroList = 8,
  Login_Reply_HeroList = 9,
  Login_Request_CreateHero = 10,
  Login_Reply_CreateHeroSuccess = 11,
  Login_Reply_CreateHeroFailed = 12,
  Login_Request_DeleteHero = 13,
  Login_Reply_DeleteHeroSuccess = 14,
  Login_Reply_DeleteHeroFailed = 15,
  World_Request_Login = 16,
  World_Reply_LoginSuccess = 17,
  World_Reply_LoginFailed = 18,
  World_Notify_LoadFinish = 19,
  World_Notify_EnterSuccess = 20,
  World_Notify_EnterFailed = 21,
  World_Request_ActionMove = 22,
  World_Request_ActionSkill = 23,
  World_Notify_Appear = 24,
  World_Notify_Disappear = 25,
  World_Notify_Update = 26,
  World_Request_Respawn = 27,
  World_Request_EnterGate = 28,
  World_Reply_EnterGateFailed = 29,
  MIN = NONE,
  MAX = World_Reply_EnterGateFailed
};

inline const char **EnumNamesMessageType() {
  static const char *names[] = {
    "NONE",
    "Notify_UnauthedAccess",
    "Login_Request_Login",
    "Login_Reply_LoginSuccess",
    "Login_Reply_LoginFailed",
    "Login_Request_Join",
    "Login_Reply_JoinSuccess",
    "Login_Reply_JoinFailed",
    "Login_Request_HeroList",
    "Login_Reply_HeroList",
    "Login_Request_CreateHero",
    "Login_Reply_CreateHeroSuccess",
    "Login_Reply_CreateHeroFailed",
    "Login_Request_DeleteHero",
    "Login_Reply_DeleteHeroSuccess",
    "Login_Reply_DeleteHeroFailed",
    "World_Request_Login",
    "World_Reply_LoginSuccess",
    "World_Reply_LoginFailed",
    "World_Notify_LoadFinish",
    "World_Notify_EnterSuccess",
    "World_Notify_EnterFailed",
    "World_Request_ActionMove",
    "World_Request_ActionSkill",
    "World_Notify_Appear",
    "World_Notify_Disappear",
    "World_Notify_Update",
    "World_Request_Respawn",
    "World_Request_EnterGate",
    "World_Reply_EnterGateFailed",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageType()[index];
}

template<typename T> struct MessageTypeTraits {
  static const MessageType enum_value = MessageType::NONE;
};

template<> struct MessageTypeTraits<ProtocolCS::Notify_UnauthedAccess> {
  static const MessageType enum_value = MessageType::Notify_UnauthedAccess;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Request_Login> {
  static const MessageType enum_value = MessageType::Login_Request_Login;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_LoginSuccess> {
  static const MessageType enum_value = MessageType::Login_Reply_LoginSuccess;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_LoginFailed> {
  static const MessageType enum_value = MessageType::Login_Reply_LoginFailed;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Request_Join> {
  static const MessageType enum_value = MessageType::Login_Request_Join;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_JoinSuccess> {
  static const MessageType enum_value = MessageType::Login_Reply_JoinSuccess;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_JoinFailed> {
  static const MessageType enum_value = MessageType::Login_Reply_JoinFailed;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Request_HeroList> {
  static const MessageType enum_value = MessageType::Login_Request_HeroList;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_HeroList> {
  static const MessageType enum_value = MessageType::Login_Reply_HeroList;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Request_CreateHero> {
  static const MessageType enum_value = MessageType::Login_Request_CreateHero;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_CreateHeroSuccess> {
  static const MessageType enum_value = MessageType::Login_Reply_CreateHeroSuccess;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_CreateHeroFailed> {
  static const MessageType enum_value = MessageType::Login_Reply_CreateHeroFailed;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Request_DeleteHero> {
  static const MessageType enum_value = MessageType::Login_Request_DeleteHero;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_DeleteHeroSuccess> {
  static const MessageType enum_value = MessageType::Login_Reply_DeleteHeroSuccess;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_DeleteHeroFailed> {
  static const MessageType enum_value = MessageType::Login_Reply_DeleteHeroFailed;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Request_Login> {
  static const MessageType enum_value = MessageType::World_Request_Login;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Reply_LoginSuccess> {
  static const MessageType enum_value = MessageType::World_Reply_LoginSuccess;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Reply_LoginFailed> {
  static const MessageType enum_value = MessageType::World_Reply_LoginFailed;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Notify_LoadFinish> {
  static const MessageType enum_value = MessageType::World_Notify_LoadFinish;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Notify_EnterSuccess> {
  static const MessageType enum_value = MessageType::World_Notify_EnterSuccess;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Notify_EnterFailed> {
  static const MessageType enum_value = MessageType::World_Notify_EnterFailed;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Request_ActionMove> {
  static const MessageType enum_value = MessageType::World_Request_ActionMove;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Request_ActionSkill> {
  static const MessageType enum_value = MessageType::World_Request_ActionSkill;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Notify_Appear> {
  static const MessageType enum_value = MessageType::World_Notify_Appear;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Notify_Disappear> {
  static const MessageType enum_value = MessageType::World_Notify_Disappear;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Notify_Update> {
  static const MessageType enum_value = MessageType::World_Notify_Update;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Request_Respawn> {
  static const MessageType enum_value = MessageType::World_Request_Respawn;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Request_EnterGate> {
  static const MessageType enum_value = MessageType::World_Request_EnterGate;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Reply_EnterGateFailed> {
  static const MessageType enum_value = MessageType::World_Reply_EnterGateFailed;
};

struct MessageTypeUnion {
  MessageType type;
  void *value;

  MessageTypeUnion() : type(MessageType::NONE), value(nullptr) {}
  MessageTypeUnion(MessageTypeUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(MessageType::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MessageTypeUnion(const MessageTypeUnion &) FLATBUFFERS_NOEXCEPT;
  MessageTypeUnion &operator=(const MessageTypeUnion &u) FLATBUFFERS_NOEXCEPT
    { MessageTypeUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MessageTypeUnion &operator=(MessageTypeUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MessageTypeUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    Reset();
    type = MessageTypeTraits<typename T::TableType>::enum_value;
    if (type != MessageType::NONE) {
      value = new T(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, MessageType type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ProtocolCS::Notify_UnauthedAccessT *AsNotify_UnauthedAccess() {
    return type == MessageType::Notify_UnauthedAccess ?
      reinterpret_cast<ProtocolCS::Notify_UnauthedAccessT *>(value) : nullptr;
  }
  ProtocolCS::Login::Request_LoginT *AsLogin_Request_Login() {
    return type == MessageType::Login_Request_Login ?
      reinterpret_cast<ProtocolCS::Login::Request_LoginT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_LoginSuccessT *AsLogin_Reply_LoginSuccess() {
    return type == MessageType::Login_Reply_LoginSuccess ?
      reinterpret_cast<ProtocolCS::Login::Reply_LoginSuccessT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_LoginFailedT *AsLogin_Reply_LoginFailed() {
    return type == MessageType::Login_Reply_LoginFailed ?
      reinterpret_cast<ProtocolCS::Login::Reply_LoginFailedT *>(value) : nullptr;
  }
  ProtocolCS::Login::Request_JoinT *AsLogin_Request_Join() {
    return type == MessageType::Login_Request_Join ?
      reinterpret_cast<ProtocolCS::Login::Request_JoinT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_JoinSuccessT *AsLogin_Reply_JoinSuccess() {
    return type == MessageType::Login_Reply_JoinSuccess ?
      reinterpret_cast<ProtocolCS::Login::Reply_JoinSuccessT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_JoinFailedT *AsLogin_Reply_JoinFailed() {
    return type == MessageType::Login_Reply_JoinFailed ?
      reinterpret_cast<ProtocolCS::Login::Reply_JoinFailedT *>(value) : nullptr;
  }
  ProtocolCS::Login::Request_HeroListT *AsLogin_Request_HeroList() {
    return type == MessageType::Login_Request_HeroList ?
      reinterpret_cast<ProtocolCS::Login::Request_HeroListT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_HeroListT *AsLogin_Reply_HeroList() {
    return type == MessageType::Login_Reply_HeroList ?
      reinterpret_cast<ProtocolCS::Login::Reply_HeroListT *>(value) : nullptr;
  }
  ProtocolCS::Login::Request_CreateHeroT *AsLogin_Request_CreateHero() {
    return type == MessageType::Login_Request_CreateHero ?
      reinterpret_cast<ProtocolCS::Login::Request_CreateHeroT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_CreateHeroSuccessT *AsLogin_Reply_CreateHeroSuccess() {
    return type == MessageType::Login_Reply_CreateHeroSuccess ?
      reinterpret_cast<ProtocolCS::Login::Reply_CreateHeroSuccessT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_CreateHeroFailedT *AsLogin_Reply_CreateHeroFailed() {
    return type == MessageType::Login_Reply_CreateHeroFailed ?
      reinterpret_cast<ProtocolCS::Login::Reply_CreateHeroFailedT *>(value) : nullptr;
  }
  ProtocolCS::Login::Request_DeleteHeroT *AsLogin_Request_DeleteHero() {
    return type == MessageType::Login_Request_DeleteHero ?
      reinterpret_cast<ProtocolCS::Login::Request_DeleteHeroT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_DeleteHeroSuccessT *AsLogin_Reply_DeleteHeroSuccess() {
    return type == MessageType::Login_Reply_DeleteHeroSuccess ?
      reinterpret_cast<ProtocolCS::Login::Reply_DeleteHeroSuccessT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_DeleteHeroFailedT *AsLogin_Reply_DeleteHeroFailed() {
    return type == MessageType::Login_Reply_DeleteHeroFailed ?
      reinterpret_cast<ProtocolCS::Login::Reply_DeleteHeroFailedT *>(value) : nullptr;
  }
  ProtocolCS::World::Request_LoginT *AsWorld_Request_Login() {
    return type == MessageType::World_Request_Login ?
      reinterpret_cast<ProtocolCS::World::Request_LoginT *>(value) : nullptr;
  }
  ProtocolCS::World::Reply_LoginSuccessT *AsWorld_Reply_LoginSuccess() {
    return type == MessageType::World_Reply_LoginSuccess ?
      reinterpret_cast<ProtocolCS::World::Reply_LoginSuccessT *>(value) : nullptr;
  }
  ProtocolCS::World::Reply_LoginFailedT *AsWorld_Reply_LoginFailed() {
    return type == MessageType::World_Reply_LoginFailed ?
      reinterpret_cast<ProtocolCS::World::Reply_LoginFailedT *>(value) : nullptr;
  }
  ProtocolCS::World::Notify_LoadFinishT *AsWorld_Notify_LoadFinish() {
    return type == MessageType::World_Notify_LoadFinish ?
      reinterpret_cast<ProtocolCS::World::Notify_LoadFinishT *>(value) : nullptr;
  }
  ProtocolCS::World::Notify_EnterSuccessT *AsWorld_Notify_EnterSuccess() {
    return type == MessageType::World_Notify_EnterSuccess ?
      reinterpret_cast<ProtocolCS::World::Notify_EnterSuccessT *>(value) : nullptr;
  }
  ProtocolCS::World::Notify_EnterFailedT *AsWorld_Notify_EnterFailed() {
    return type == MessageType::World_Notify_EnterFailed ?
      reinterpret_cast<ProtocolCS::World::Notify_EnterFailedT *>(value) : nullptr;
  }
  ProtocolCS::World::Request_ActionMoveT *AsWorld_Request_ActionMove() {
    return type == MessageType::World_Request_ActionMove ?
      reinterpret_cast<ProtocolCS::World::Request_ActionMoveT *>(value) : nullptr;
  }
  ProtocolCS::World::Request_ActionSkillT *AsWorld_Request_ActionSkill() {
    return type == MessageType::World_Request_ActionSkill ?
      reinterpret_cast<ProtocolCS::World::Request_ActionSkillT *>(value) : nullptr;
  }
  ProtocolCS::World::Notify_AppearT *AsWorld_Notify_Appear() {
    return type == MessageType::World_Notify_Appear ?
      reinterpret_cast<ProtocolCS::World::Notify_AppearT *>(value) : nullptr;
  }
  ProtocolCS::World::Notify_DisappearT *AsWorld_Notify_Disappear() {
    return type == MessageType::World_Notify_Disappear ?
      reinterpret_cast<ProtocolCS::World::Notify_DisappearT *>(value) : nullptr;
  }
  ProtocolCS::World::Notify_UpdateT *AsWorld_Notify_Update() {
    return type == MessageType::World_Notify_Update ?
      reinterpret_cast<ProtocolCS::World::Notify_UpdateT *>(value) : nullptr;
  }
  ProtocolCS::World::Request_RespawnT *AsWorld_Request_Respawn() {
    return type == MessageType::World_Request_Respawn ?
      reinterpret_cast<ProtocolCS::World::Request_RespawnT *>(value) : nullptr;
  }
  ProtocolCS::World::Request_EnterGateT *AsWorld_Request_EnterGate() {
    return type == MessageType::World_Request_EnterGate ?
      reinterpret_cast<ProtocolCS::World::Request_EnterGateT *>(value) : nullptr;
  }
  ProtocolCS::World::Reply_EnterGateFailedT *AsWorld_Reply_EnterGateFailed() {
    return type == MessageType::World_Reply_EnterGateFailed ?
      reinterpret_cast<ProtocolCS::World::Reply_EnterGateFailedT *>(value) : nullptr;
  }
};

bool VerifyMessageType(flatbuffers::Verifier &verifier, const void *obj, MessageType type);
bool VerifyMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() {
    memset(this, 0, sizeof(Vec2));
  }
  Vec2(const Vec2 &_o) {
    memcpy(this, &_o, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
};
STRUCT_END(Vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(const Vec3 &_o) {
    memcpy(this, &_o, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
};
STRUCT_END(Vec3, 12);

struct Notify_UnauthedAccessT : public flatbuffers::NativeTable {
  typedef Notify_UnauthedAccess TableType;
  Notify_UnauthedAccessT() {
  }
};

struct Notify_UnauthedAccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_UnauthedAccessT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Notify_UnauthedAccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_UnauthedAccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_UnauthedAccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_UnauthedAccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Notify_UnauthedAccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_UnauthedAccessBuilder &operator=(const Notify_UnauthedAccessBuilder &);
  flatbuffers::Offset<Notify_UnauthedAccess> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Notify_UnauthedAccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_UnauthedAccess> CreateNotify_UnauthedAccess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Notify_UnauthedAccessBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Notify_UnauthedAccess> CreateNotify_UnauthedAccess(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace Login {

struct HeroT : public flatbuffers::NativeTable {
  typedef Hero TableType;
  int32_t uid;
  std::string name;
  ProtocolCS::ClassType class_type;
  int32_t level;
  HeroT()
      : uid(0),
        class_type(ProtocolCS::ClassType::NONE),
        level(0) {
  }
};

struct Hero FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeroT NativeTableType;
  enum {
    VT_UID = 4,
    VT_NAME = 6,
    VT_CLASS_TYPE = 8,
    VT_LEVEL = 10
  };
  int32_t uid() const {
    return GetField<int32_t>(VT_UID, 0);
  }
  bool mutate_uid(int32_t _uid) {
    return SetField<int32_t>(VT_UID, _uid, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  ProtocolCS::ClassType class_type() const {
    return static_cast<ProtocolCS::ClassType>(GetField<int32_t>(VT_CLASS_TYPE, 0));
  }
  bool mutate_class_type(ProtocolCS::ClassType _class_type) {
    return SetField<int32_t>(VT_CLASS_TYPE, static_cast<int32_t>(_class_type), 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool mutate_level(int32_t _level) {
    return SetField<int32_t>(VT_LEVEL, _level, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
  HeroT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeroT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Hero> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeroT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeroBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uid(int32_t uid) {
    fbb_.AddElement<int32_t>(Hero::VT_UID, uid, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Hero::VT_NAME, name);
  }
  void add_class_type(ProtocolCS::ClassType class_type) {
    fbb_.AddElement<int32_t>(Hero::VT_CLASS_TYPE, static_cast<int32_t>(class_type), 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(Hero::VT_LEVEL, level, 0);
  }
  HeroBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeroBuilder &operator=(const HeroBuilder &);
  flatbuffers::Offset<Hero> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Hero>(end);
    return o;
  }
};

inline flatbuffers::Offset<Hero> CreateHero(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t uid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    ProtocolCS::ClassType class_type = ProtocolCS::ClassType::NONE,
    int32_t level = 0) {
  HeroBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  builder_.add_uid(uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<Hero> CreateHeroDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t uid = 0,
    const char *name = nullptr,
    ProtocolCS::ClassType class_type = ProtocolCS::ClassType::NONE,
    int32_t level = 0) {
  return ProtocolCS::Login::CreateHero(
      _fbb,
      uid,
      name ? _fbb.CreateString(name) : 0,
      class_type,
      level);
}

flatbuffers::Offset<Hero> CreateHero(flatbuffers::FlatBufferBuilder &_fbb, const HeroT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_LoginT : public flatbuffers::NativeTable {
  typedef Request_Login TableType;
  std::string user_name;
  std::string password;
  Request_LoginT() {
  }
};

struct Request_Login FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_LoginT NativeTableType;
  enum {
    VT_USER_NAME = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *user_name() const {
    return GetPointer<const flatbuffers::String *>(VT_USER_NAME);
  }
  flatbuffers::String *mutable_user_name() {
    return GetPointer<flatbuffers::String *>(VT_USER_NAME);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  flatbuffers::String *mutable_password() {
    return GetPointer<flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER_NAME) &&
           verifier.Verify(user_name()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
  Request_LoginT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_LoginT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Login> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_LoginBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_user_name(flatbuffers::Offset<flatbuffers::String> user_name) {
    fbb_.AddOffset(Request_Login::VT_USER_NAME, user_name);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(Request_Login::VT_PASSWORD, password);
  }
  Request_LoginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_LoginBuilder &operator=(const Request_LoginBuilder &);
  flatbuffers::Offset<Request_Login> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Request_Login>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Login> CreateRequest_Login(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> user_name = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  Request_LoginBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_user_name(user_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Login> CreateRequest_LoginDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *user_name = nullptr,
    const char *password = nullptr) {
  return ProtocolCS::Login::CreateRequest_Login(
      _fbb,
      user_name ? _fbb.CreateString(user_name) : 0,
      password ? _fbb.CreateString(password) : 0);
}

flatbuffers::Offset<Request_Login> CreateRequest_Login(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_LoginSuccessT : public flatbuffers::NativeTable {
  typedef Reply_LoginSuccess TableType;
  std::string credential;
  Reply_LoginSuccessT() {
  }
};

struct Reply_LoginSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_LoginSuccessT NativeTableType;
  enum {
    VT_CREDENTIAL = 4
  };
  const flatbuffers::String *credential() const {
    return GetPointer<const flatbuffers::String *>(VT_CREDENTIAL);
  }
  flatbuffers::String *mutable_credential() {
    return GetPointer<flatbuffers::String *>(VT_CREDENTIAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CREDENTIAL) &&
           verifier.Verify(credential()) &&
           verifier.EndTable();
  }
  Reply_LoginSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_LoginSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_LoginSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_LoginSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_credential(flatbuffers::Offset<flatbuffers::String> credential) {
    fbb_.AddOffset(Reply_LoginSuccess::VT_CREDENTIAL, credential);
  }
  Reply_LoginSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_LoginSuccessBuilder &operator=(const Reply_LoginSuccessBuilder &);
  flatbuffers::Offset<Reply_LoginSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_LoginSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> credential = 0) {
  Reply_LoginSuccessBuilder builder_(_fbb);
  builder_.add_credential(credential);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccessDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *credential = nullptr) {
  return ProtocolCS::Login::CreateReply_LoginSuccess(
      _fbb,
      credential ? _fbb.CreateString(credential) : 0);
}

flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_LoginFailedT : public flatbuffers::NativeTable {
  typedef Reply_LoginFailed TableType;
  ProtocolCS::ErrorCode error_code;
  Reply_LoginFailedT()
      : error_code(ProtocolCS::ErrorCode::OK) {
  }
};

struct Reply_LoginFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_LoginFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ProtocolCS::ErrorCode error_code() const {
    return static_cast<ProtocolCS::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ProtocolCS::ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_LoginFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_LoginFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_LoginFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_LoginFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ProtocolCS::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_LoginFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_LoginFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_LoginFailedBuilder &operator=(const Reply_LoginFailedBuilder &);
  flatbuffers::Offset<Reply_LoginFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_LoginFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_LoginFailed> CreateReply_LoginFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::ErrorCode error_code = ProtocolCS::ErrorCode::OK) {
  Reply_LoginFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_LoginFailed> CreateReply_LoginFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_JoinT : public flatbuffers::NativeTable {
  typedef Request_Join TableType;
  std::string user_name;
  std::string password;
  Request_JoinT() {
  }
};

struct Request_Join FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_JoinT NativeTableType;
  enum {
    VT_USER_NAME = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *user_name() const {
    return GetPointer<const flatbuffers::String *>(VT_USER_NAME);
  }
  flatbuffers::String *mutable_user_name() {
    return GetPointer<flatbuffers::String *>(VT_USER_NAME);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  flatbuffers::String *mutable_password() {
    return GetPointer<flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER_NAME) &&
           verifier.Verify(user_name()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
  Request_JoinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_JoinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Join> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_JoinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_JoinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_user_name(flatbuffers::Offset<flatbuffers::String> user_name) {
    fbb_.AddOffset(Request_Join::VT_USER_NAME, user_name);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(Request_Join::VT_PASSWORD, password);
  }
  Request_JoinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_JoinBuilder &operator=(const Request_JoinBuilder &);
  flatbuffers::Offset<Request_Join> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Request_Join>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Join> CreateRequest_Join(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> user_name = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  Request_JoinBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_user_name(user_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Join> CreateRequest_JoinDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *user_name = nullptr,
    const char *password = nullptr) {
  return ProtocolCS::Login::CreateRequest_Join(
      _fbb,
      user_name ? _fbb.CreateString(user_name) : 0,
      password ? _fbb.CreateString(password) : 0);
}

flatbuffers::Offset<Request_Join> CreateRequest_Join(flatbuffers::FlatBufferBuilder &_fbb, const Request_JoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_JoinSuccessT : public flatbuffers::NativeTable {
  typedef Reply_JoinSuccess TableType;
  Reply_JoinSuccessT() {
  }
};

struct Reply_JoinSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_JoinSuccessT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Reply_JoinSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_JoinSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_JoinSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_JoinSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Reply_JoinSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_JoinSuccessBuilder &operator=(const Reply_JoinSuccessBuilder &);
  flatbuffers::Offset<Reply_JoinSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Reply_JoinSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_JoinSuccess> CreateReply_JoinSuccess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Reply_JoinSuccessBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_JoinSuccess> CreateReply_JoinSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_JoinFailedT : public flatbuffers::NativeTable {
  typedef Reply_JoinFailed TableType;
  ProtocolCS::ErrorCode error_code;
  Reply_JoinFailedT()
      : error_code(ProtocolCS::ErrorCode::OK) {
  }
};

struct Reply_JoinFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_JoinFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ProtocolCS::ErrorCode error_code() const {
    return static_cast<ProtocolCS::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ProtocolCS::ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_JoinFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_JoinFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_JoinFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_JoinFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ProtocolCS::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_JoinFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_JoinFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_JoinFailedBuilder &operator=(const Reply_JoinFailedBuilder &);
  flatbuffers::Offset<Reply_JoinFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_JoinFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_JoinFailed> CreateReply_JoinFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::ErrorCode error_code = ProtocolCS::ErrorCode::OK) {
  Reply_JoinFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_JoinFailed> CreateReply_JoinFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_HeroListT : public flatbuffers::NativeTable {
  typedef Request_HeroList TableType;
  Request_HeroListT() {
  }
};

struct Request_HeroList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_HeroListT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Request_HeroListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_HeroListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_HeroList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_HeroListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_HeroListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Request_HeroListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_HeroListBuilder &operator=(const Request_HeroListBuilder &);
  flatbuffers::Offset<Request_HeroList> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Request_HeroList>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_HeroList> CreateRequest_HeroList(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Request_HeroListBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Request_HeroList> CreateRequest_HeroList(flatbuffers::FlatBufferBuilder &_fbb, const Request_HeroListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_HeroListT : public flatbuffers::NativeTable {
  typedef Reply_HeroList TableType;
  std::vector<std::unique_ptr<HeroT>> list;
  Reply_HeroListT() {
  }
};

struct Reply_HeroList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_HeroListT NativeTableType;
  enum {
    VT_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Hero>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Hero>> *>(VT_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<Hero>> *mutable_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Hero>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.Verify(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           verifier.EndTable();
  }
  Reply_HeroListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_HeroListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_HeroList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_HeroListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_HeroListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Hero>>> list) {
    fbb_.AddOffset(Reply_HeroList::VT_LIST, list);
  }
  Reply_HeroListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_HeroListBuilder &operator=(const Reply_HeroListBuilder &);
  flatbuffers::Offset<Reply_HeroList> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_HeroList>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_HeroList> CreateReply_HeroList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Hero>>> list = 0) {
  Reply_HeroListBuilder builder_(_fbb);
  builder_.add_list(list);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reply_HeroList> CreateReply_HeroListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Hero>> *list = nullptr) {
  return ProtocolCS::Login::CreateReply_HeroList(
      _fbb,
      list ? _fbb.CreateVector<flatbuffers::Offset<Hero>>(*list) : 0);
}

flatbuffers::Offset<Reply_HeroList> CreateReply_HeroList(flatbuffers::FlatBufferBuilder &_fbb, const Reply_HeroListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_CreateHeroT : public flatbuffers::NativeTable {
  typedef Request_CreateHero TableType;
  std::string name;
  ProtocolCS::ClassType class_type;
  Request_CreateHeroT()
      : class_type(ProtocolCS::ClassType::NONE) {
  }
};

struct Request_CreateHero FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_CreateHeroT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_CLASS_TYPE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  ProtocolCS::ClassType class_type() const {
    return static_cast<ProtocolCS::ClassType>(GetField<int32_t>(VT_CLASS_TYPE, 0));
  }
  bool mutate_class_type(ProtocolCS::ClassType _class_type) {
    return SetField<int32_t>(VT_CLASS_TYPE, static_cast<int32_t>(_class_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           verifier.EndTable();
  }
  Request_CreateHeroT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_CreateHeroT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_CreateHero> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_CreateHeroT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_CreateHeroBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Request_CreateHero::VT_NAME, name);
  }
  void add_class_type(ProtocolCS::ClassType class_type) {
    fbb_.AddElement<int32_t>(Request_CreateHero::VT_CLASS_TYPE, static_cast<int32_t>(class_type), 0);
  }
  Request_CreateHeroBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_CreateHeroBuilder &operator=(const Request_CreateHeroBuilder &);
  flatbuffers::Offset<Request_CreateHero> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Request_CreateHero>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_CreateHero> CreateRequest_CreateHero(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    ProtocolCS::ClassType class_type = ProtocolCS::ClassType::NONE) {
  Request_CreateHeroBuilder builder_(_fbb);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_CreateHero> CreateRequest_CreateHeroDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ProtocolCS::ClassType class_type = ProtocolCS::ClassType::NONE) {
  return ProtocolCS::Login::CreateRequest_CreateHero(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      class_type);
}

flatbuffers::Offset<Request_CreateHero> CreateRequest_CreateHero(flatbuffers::FlatBufferBuilder &_fbb, const Request_CreateHeroT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_CreateHeroSuccessT : public flatbuffers::NativeTable {
  typedef Reply_CreateHeroSuccess TableType;
  std::unique_ptr<HeroT> hero;
  Reply_CreateHeroSuccessT() {
  }
};

struct Reply_CreateHeroSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_CreateHeroSuccessT NativeTableType;
  enum {
    VT_HERO = 4
  };
  const Hero *hero() const {
    return GetPointer<const Hero *>(VT_HERO);
  }
  Hero *mutable_hero() {
    return GetPointer<Hero *>(VT_HERO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HERO) &&
           verifier.VerifyTable(hero()) &&
           verifier.EndTable();
  }
  Reply_CreateHeroSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_CreateHeroSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_CreateHeroSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateHeroSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_CreateHeroSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hero(flatbuffers::Offset<Hero> hero) {
    fbb_.AddOffset(Reply_CreateHeroSuccess::VT_HERO, hero);
  }
  Reply_CreateHeroSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_CreateHeroSuccessBuilder &operator=(const Reply_CreateHeroSuccessBuilder &);
  flatbuffers::Offset<Reply_CreateHeroSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_CreateHeroSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_CreateHeroSuccess> CreateReply_CreateHeroSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Hero> hero = 0) {
  Reply_CreateHeroSuccessBuilder builder_(_fbb);
  builder_.add_hero(hero);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_CreateHeroSuccess> CreateReply_CreateHeroSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateHeroSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_CreateHeroFailedT : public flatbuffers::NativeTable {
  typedef Reply_CreateHeroFailed TableType;
  ProtocolCS::ErrorCode error_code;
  Reply_CreateHeroFailedT()
      : error_code(ProtocolCS::ErrorCode::OK) {
  }
};

struct Reply_CreateHeroFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_CreateHeroFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ProtocolCS::ErrorCode error_code() const {
    return static_cast<ProtocolCS::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ProtocolCS::ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_CreateHeroFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_CreateHeroFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_CreateHeroFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateHeroFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_CreateHeroFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ProtocolCS::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_CreateHeroFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_CreateHeroFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_CreateHeroFailedBuilder &operator=(const Reply_CreateHeroFailedBuilder &);
  flatbuffers::Offset<Reply_CreateHeroFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_CreateHeroFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_CreateHeroFailed> CreateReply_CreateHeroFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::ErrorCode error_code = ProtocolCS::ErrorCode::OK) {
  Reply_CreateHeroFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_CreateHeroFailed> CreateReply_CreateHeroFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateHeroFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_DeleteHeroT : public flatbuffers::NativeTable {
  typedef Request_DeleteHero TableType;
  int32_t hero_uid;
  Request_DeleteHeroT()
      : hero_uid(0) {
  }
};

struct Request_DeleteHero FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_DeleteHeroT NativeTableType;
  enum {
    VT_HERO_UID = 4
  };
  int32_t hero_uid() const {
    return GetField<int32_t>(VT_HERO_UID, 0);
  }
  bool mutate_hero_uid(int32_t _hero_uid) {
    return SetField<int32_t>(VT_HERO_UID, _hero_uid, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HERO_UID) &&
           verifier.EndTable();
  }
  Request_DeleteHeroT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_DeleteHeroT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_DeleteHero> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_DeleteHeroT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_DeleteHeroBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hero_uid(int32_t hero_uid) {
    fbb_.AddElement<int32_t>(Request_DeleteHero::VT_HERO_UID, hero_uid, 0);
  }
  Request_DeleteHeroBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_DeleteHeroBuilder &operator=(const Request_DeleteHeroBuilder &);
  flatbuffers::Offset<Request_DeleteHero> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Request_DeleteHero>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_DeleteHero> CreateRequest_DeleteHero(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t hero_uid = 0) {
  Request_DeleteHeroBuilder builder_(_fbb);
  builder_.add_hero_uid(hero_uid);
  return builder_.Finish();
}

flatbuffers::Offset<Request_DeleteHero> CreateRequest_DeleteHero(flatbuffers::FlatBufferBuilder &_fbb, const Request_DeleteHeroT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_DeleteHeroSuccessT : public flatbuffers::NativeTable {
  typedef Reply_DeleteHeroSuccess TableType;
  int32_t hero_uid;
  Reply_DeleteHeroSuccessT()
      : hero_uid(0) {
  }
};

struct Reply_DeleteHeroSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_DeleteHeroSuccessT NativeTableType;
  enum {
    VT_HERO_UID = 4
  };
  int32_t hero_uid() const {
    return GetField<int32_t>(VT_HERO_UID, 0);
  }
  bool mutate_hero_uid(int32_t _hero_uid) {
    return SetField<int32_t>(VT_HERO_UID, _hero_uid, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HERO_UID) &&
           verifier.EndTable();
  }
  Reply_DeleteHeroSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_DeleteHeroSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_DeleteHeroSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteHeroSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_DeleteHeroSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hero_uid(int32_t hero_uid) {
    fbb_.AddElement<int32_t>(Reply_DeleteHeroSuccess::VT_HERO_UID, hero_uid, 0);
  }
  Reply_DeleteHeroSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_DeleteHeroSuccessBuilder &operator=(const Reply_DeleteHeroSuccessBuilder &);
  flatbuffers::Offset<Reply_DeleteHeroSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_DeleteHeroSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_DeleteHeroSuccess> CreateReply_DeleteHeroSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t hero_uid = 0) {
  Reply_DeleteHeroSuccessBuilder builder_(_fbb);
  builder_.add_hero_uid(hero_uid);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_DeleteHeroSuccess> CreateReply_DeleteHeroSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteHeroSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_DeleteHeroFailedT : public flatbuffers::NativeTable {
  typedef Reply_DeleteHeroFailed TableType;
  ProtocolCS::ErrorCode error_code;
  Reply_DeleteHeroFailedT()
      : error_code(ProtocolCS::ErrorCode::OK) {
  }
};

struct Reply_DeleteHeroFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_DeleteHeroFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ProtocolCS::ErrorCode error_code() const {
    return static_cast<ProtocolCS::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ProtocolCS::ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_DeleteHeroFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_DeleteHeroFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_DeleteHeroFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteHeroFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_DeleteHeroFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ProtocolCS::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_DeleteHeroFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_DeleteHeroFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_DeleteHeroFailedBuilder &operator=(const Reply_DeleteHeroFailedBuilder &);
  flatbuffers::Offset<Reply_DeleteHeroFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_DeleteHeroFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_DeleteHeroFailed> CreateReply_DeleteHeroFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::ErrorCode error_code = ProtocolCS::ErrorCode::OK) {
  Reply_DeleteHeroFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_DeleteHeroFailed> CreateReply_DeleteHeroFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteHeroFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace Login

namespace World {

struct HeroT : public flatbuffers::NativeTable {
  typedef Hero TableType;
  std::string entity_id;
  int32_t uid;
  std::string name;
  ProtocolCS::ClassType class_type;
  int32_t exp;
  int32_t level;
  int32_t max_hp;
  int32_t hp;
  int32_t max_mp;
  int32_t mp;
  int32_t att;
  int32_t def;
  int32_t map_id;
  std::unique_ptr<ProtocolCS::Vec3> pos;
  float rotation;
  HeroT()
      : uid(0),
        class_type(ProtocolCS::ClassType::NONE),
        exp(0),
        level(0),
        max_hp(0),
        hp(0),
        max_mp(0),
        mp(0),
        att(0),
        def(0),
        map_id(0),
        rotation(0.0f) {
  }
};

struct Hero FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeroT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_UID = 6,
    VT_NAME = 8,
    VT_CLASS_TYPE = 10,
    VT_EXP = 12,
    VT_LEVEL = 14,
    VT_MAX_HP = 16,
    VT_HP = 18,
    VT_MAX_MP = 20,
    VT_MP = 22,
    VT_ATT = 24,
    VT_DEF = 26,
    VT_MAP_ID = 28,
    VT_POS = 30,
    VT_ROTATION = 32
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  int32_t uid() const {
    return GetField<int32_t>(VT_UID, 0);
  }
  bool mutate_uid(int32_t _uid) {
    return SetField<int32_t>(VT_UID, _uid, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  ProtocolCS::ClassType class_type() const {
    return static_cast<ProtocolCS::ClassType>(GetField<int32_t>(VT_CLASS_TYPE, 0));
  }
  bool mutate_class_type(ProtocolCS::ClassType _class_type) {
    return SetField<int32_t>(VT_CLASS_TYPE, static_cast<int32_t>(_class_type), 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  bool mutate_exp(int32_t _exp) {
    return SetField<int32_t>(VT_EXP, _exp, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool mutate_level(int32_t _level) {
    return SetField<int32_t>(VT_LEVEL, _level, 0);
  }
  int32_t max_hp() const {
    return GetField<int32_t>(VT_MAX_HP, 0);
  }
  bool mutate_max_hp(int32_t _max_hp) {
    return SetField<int32_t>(VT_MAX_HP, _max_hp, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  bool mutate_hp(int32_t _hp) {
    return SetField<int32_t>(VT_HP, _hp, 0);
  }
  int32_t max_mp() const {
    return GetField<int32_t>(VT_MAX_MP, 0);
  }
  bool mutate_max_mp(int32_t _max_mp) {
    return SetField<int32_t>(VT_MAX_MP, _max_mp, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  bool mutate_mp(int32_t _mp) {
    return SetField<int32_t>(VT_MP, _mp, 0);
  }
  int32_t att() const {
    return GetField<int32_t>(VT_ATT, 0);
  }
  bool mutate_att(int32_t _att) {
    return SetField<int32_t>(VT_ATT, _att, 0);
  }
  int32_t def() const {
    return GetField<int32_t>(VT_DEF, 0);
  }
  bool mutate_def(int32_t _def) {
    return SetField<int32_t>(VT_DEF, _def, 0);
  }
  int32_t map_id() const {
    return GetField<int32_t>(VT_MAP_ID, 0);
  }
  bool mutate_map_id(int32_t _map_id) {
    return SetField<int32_t>(VT_MAP_ID, _map_id, 0);
  }
  const ProtocolCS::Vec3 *pos() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_POS);
  }
  ProtocolCS::Vec3 *mutable_pos() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_POS);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool mutate_rotation(float _rotation) {
    return SetField<float>(VT_ROTATION, _rotation, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyField<int32_t>(verifier, VT_UID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_MAX_HP) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MAX_MP) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<int32_t>(verifier, VT_ATT) &&
           VerifyField<int32_t>(verifier, VT_DEF) &&
           VerifyField<int32_t>(verifier, VT_MAP_ID) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_POS) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
  HeroT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeroT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Hero> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeroT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeroBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(Hero::VT_ENTITY_ID, entity_id);
  }
  void add_uid(int32_t uid) {
    fbb_.AddElement<int32_t>(Hero::VT_UID, uid, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Hero::VT_NAME, name);
  }
  void add_class_type(ProtocolCS::ClassType class_type) {
    fbb_.AddElement<int32_t>(Hero::VT_CLASS_TYPE, static_cast<int32_t>(class_type), 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(Hero::VT_EXP, exp, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(Hero::VT_LEVEL, level, 0);
  }
  void add_max_hp(int32_t max_hp) {
    fbb_.AddElement<int32_t>(Hero::VT_MAX_HP, max_hp, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(Hero::VT_HP, hp, 0);
  }
  void add_max_mp(int32_t max_mp) {
    fbb_.AddElement<int32_t>(Hero::VT_MAX_MP, max_mp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(Hero::VT_MP, mp, 0);
  }
  void add_att(int32_t att) {
    fbb_.AddElement<int32_t>(Hero::VT_ATT, att, 0);
  }
  void add_def(int32_t def) {
    fbb_.AddElement<int32_t>(Hero::VT_DEF, def, 0);
  }
  void add_map_id(int32_t map_id) {
    fbb_.AddElement<int32_t>(Hero::VT_MAP_ID, map_id, 0);
  }
  void add_pos(const ProtocolCS::Vec3 *pos) {
    fbb_.AddStruct(Hero::VT_POS, pos);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(Hero::VT_ROTATION, rotation, 0.0f);
  }
  HeroBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeroBuilder &operator=(const HeroBuilder &);
  flatbuffers::Offset<Hero> Finish() {
    const auto end = fbb_.EndTable(start_, 15);
    auto o = flatbuffers::Offset<Hero>(end);
    return o;
  }
};

inline flatbuffers::Offset<Hero> CreateHero(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    int32_t uid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    ProtocolCS::ClassType class_type = ProtocolCS::ClassType::NONE,
    int32_t exp = 0,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    int32_t att = 0,
    int32_t def = 0,
    int32_t map_id = 0,
    const ProtocolCS::Vec3 *pos = 0,
    float rotation = 0.0f) {
  HeroBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_pos(pos);
  builder_.add_map_id(map_id);
  builder_.add_def(def);
  builder_.add_att(att);
  builder_.add_mp(mp);
  builder_.add_max_mp(max_mp);
  builder_.add_hp(hp);
  builder_.add_max_hp(max_hp);
  builder_.add_level(level);
  builder_.add_exp(exp);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  builder_.add_uid(uid);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Hero> CreateHeroDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    int32_t uid = 0,
    const char *name = nullptr,
    ProtocolCS::ClassType class_type = ProtocolCS::ClassType::NONE,
    int32_t exp = 0,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    int32_t att = 0,
    int32_t def = 0,
    int32_t map_id = 0,
    const ProtocolCS::Vec3 *pos = 0,
    float rotation = 0.0f) {
  return ProtocolCS::World::CreateHero(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      uid,
      name ? _fbb.CreateString(name) : 0,
      class_type,
      exp,
      level,
      max_hp,
      hp,
      max_mp,
      mp,
      att,
      def,
      map_id,
      pos,
      rotation);
}

flatbuffers::Offset<Hero> CreateHero(flatbuffers::FlatBufferBuilder &_fbb, const HeroT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MonsterT : public flatbuffers::NativeTable {
  typedef Monster TableType;
  std::string entity_id;
  int32_t uid;
  int32_t type_id;
  std::string name;
  int32_t level;
  int32_t max_hp;
  int32_t hp;
  int32_t max_mp;
  int32_t mp;
  std::unique_ptr<ProtocolCS::Vec3> pos;
  float rotation;
  MonsterT()
      : uid(0),
        type_id(0),
        level(0),
        max_hp(0),
        hp(0),
        max_mp(0),
        mp(0),
        rotation(0.0f) {
  }
};

struct Monster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MonsterT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_UID = 6,
    VT_TYPE_ID = 8,
    VT_NAME = 10,
    VT_LEVEL = 12,
    VT_MAX_HP = 14,
    VT_HP = 16,
    VT_MAX_MP = 18,
    VT_MP = 20,
    VT_POS = 22,
    VT_ROTATION = 24
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  int32_t uid() const {
    return GetField<int32_t>(VT_UID, 0);
  }
  bool mutate_uid(int32_t _uid) {
    return SetField<int32_t>(VT_UID, _uid, 0);
  }
  int32_t type_id() const {
    return GetField<int32_t>(VT_TYPE_ID, 0);
  }
  bool mutate_type_id(int32_t _type_id) {
    return SetField<int32_t>(VT_TYPE_ID, _type_id, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool mutate_level(int32_t _level) {
    return SetField<int32_t>(VT_LEVEL, _level, 0);
  }
  int32_t max_hp() const {
    return GetField<int32_t>(VT_MAX_HP, 0);
  }
  bool mutate_max_hp(int32_t _max_hp) {
    return SetField<int32_t>(VT_MAX_HP, _max_hp, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  bool mutate_hp(int32_t _hp) {
    return SetField<int32_t>(VT_HP, _hp, 0);
  }
  int32_t max_mp() const {
    return GetField<int32_t>(VT_MAX_MP, 0);
  }
  bool mutate_max_mp(int32_t _max_mp) {
    return SetField<int32_t>(VT_MAX_MP, _max_mp, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  bool mutate_mp(int32_t _mp) {
    return SetField<int32_t>(VT_MP, _mp, 0);
  }
  const ProtocolCS::Vec3 *pos() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_POS);
  }
  ProtocolCS::Vec3 *mutable_pos() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_POS);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool mutate_rotation(float _rotation) {
    return SetField<float>(VT_ROTATION, _rotation, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyField<int32_t>(verifier, VT_UID) &&
           VerifyField<int32_t>(verifier, VT_TYPE_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_MAX_HP) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MAX_MP) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_POS) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
  MonsterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MonsterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Monster> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MonsterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(Monster::VT_ENTITY_ID, entity_id);
  }
  void add_uid(int32_t uid) {
    fbb_.AddElement<int32_t>(Monster::VT_UID, uid, 0);
  }
  void add_type_id(int32_t type_id) {
    fbb_.AddElement<int32_t>(Monster::VT_TYPE_ID, type_id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Monster::VT_NAME, name);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(Monster::VT_LEVEL, level, 0);
  }
  void add_max_hp(int32_t max_hp) {
    fbb_.AddElement<int32_t>(Monster::VT_MAX_HP, max_hp, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(Monster::VT_HP, hp, 0);
  }
  void add_max_mp(int32_t max_mp) {
    fbb_.AddElement<int32_t>(Monster::VT_MAX_MP, max_mp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(Monster::VT_MP, mp, 0);
  }
  void add_pos(const ProtocolCS::Vec3 *pos) {
    fbb_.AddStruct(Monster::VT_POS, pos);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(Monster::VT_ROTATION, rotation, 0.0f);
  }
  MonsterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MonsterBuilder &operator=(const MonsterBuilder &);
  flatbuffers::Offset<Monster> Finish() {
    const auto end = fbb_.EndTable(start_, 11);
    auto o = flatbuffers::Offset<Monster>(end);
    return o;
  }
};

inline flatbuffers::Offset<Monster> CreateMonster(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    int32_t uid = 0,
    int32_t type_id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    const ProtocolCS::Vec3 *pos = 0,
    float rotation = 0.0f) {
  MonsterBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_pos(pos);
  builder_.add_mp(mp);
  builder_.add_max_mp(max_mp);
  builder_.add_hp(hp);
  builder_.add_max_hp(max_hp);
  builder_.add_level(level);
  builder_.add_name(name);
  builder_.add_type_id(type_id);
  builder_.add_uid(uid);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Monster> CreateMonsterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    int32_t uid = 0,
    int32_t type_id = 0,
    const char *name = nullptr,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    const ProtocolCS::Vec3 *pos = 0,
    float rotation = 0.0f) {
  return ProtocolCS::World::CreateMonster(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      uid,
      type_id,
      name ? _fbb.CreateString(name) : 0,
      level,
      max_hp,
      hp,
      max_mp,
      mp,
      pos,
      rotation);
}

flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GateInfoT : public flatbuffers::NativeTable {
  typedef GateInfo TableType;
  int32_t uid;
  std::unique_ptr<ProtocolCS::Vec3> pos;
  ProtocolCS::MapType map_type;
  GateInfoT()
      : uid(0),
        map_type(ProtocolCS::MapType::NONE) {
  }
};

struct GateInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GateInfoT NativeTableType;
  enum {
    VT_UID = 4,
    VT_POS = 6,
    VT_MAP_TYPE = 8
  };
  int32_t uid() const {
    return GetField<int32_t>(VT_UID, 0);
  }
  bool mutate_uid(int32_t _uid) {
    return SetField<int32_t>(VT_UID, _uid, 0);
  }
  const ProtocolCS::Vec3 *pos() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_POS);
  }
  ProtocolCS::Vec3 *mutable_pos() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_POS);
  }
  ProtocolCS::MapType map_type() const {
    return static_cast<ProtocolCS::MapType>(GetField<int32_t>(VT_MAP_TYPE, 0));
  }
  bool mutate_map_type(ProtocolCS::MapType _map_type) {
    return SetField<int32_t>(VT_MAP_TYPE, static_cast<int32_t>(_map_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UID) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_POS) &&
           VerifyField<int32_t>(verifier, VT_MAP_TYPE) &&
           verifier.EndTable();
  }
  GateInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GateInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GateInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GateInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GateInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uid(int32_t uid) {
    fbb_.AddElement<int32_t>(GateInfo::VT_UID, uid, 0);
  }
  void add_pos(const ProtocolCS::Vec3 *pos) {
    fbb_.AddStruct(GateInfo::VT_POS, pos);
  }
  void add_map_type(ProtocolCS::MapType map_type) {
    fbb_.AddElement<int32_t>(GateInfo::VT_MAP_TYPE, static_cast<int32_t>(map_type), 0);
  }
  GateInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GateInfoBuilder &operator=(const GateInfoBuilder &);
  flatbuffers::Offset<GateInfo> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<GateInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GateInfo> CreateGateInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t uid = 0,
    const ProtocolCS::Vec3 *pos = 0,
    ProtocolCS::MapType map_type = ProtocolCS::MapType::NONE) {
  GateInfoBuilder builder_(_fbb);
  builder_.add_map_type(map_type);
  builder_.add_pos(pos);
  builder_.add_uid(uid);
  return builder_.Finish();
}

flatbuffers::Offset<GateInfo> CreateGateInfo(flatbuffers::FlatBufferBuilder &_fbb, const GateInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapDataT : public flatbuffers::NativeTable {
  typedef MapData TableType;
  std::string entity_id;
  int32_t map_id;
  ProtocolCS::MapType map_type;
  std::vector<std::unique_ptr<GateInfoT>> map_gates;
  MapDataT()
      : map_id(0),
        map_type(ProtocolCS::MapType::NONE) {
  }
};

struct MapData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapDataT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_MAP_ID = 6,
    VT_MAP_TYPE = 8,
    VT_MAP_GATES = 10
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  int32_t map_id() const {
    return GetField<int32_t>(VT_MAP_ID, 0);
  }
  bool mutate_map_id(int32_t _map_id) {
    return SetField<int32_t>(VT_MAP_ID, _map_id, 0);
  }
  ProtocolCS::MapType map_type() const {
    return static_cast<ProtocolCS::MapType>(GetField<int32_t>(VT_MAP_TYPE, 0));
  }
  bool mutate_map_type(ProtocolCS::MapType _map_type) {
    return SetField<int32_t>(VT_MAP_TYPE, static_cast<int32_t>(_map_type), 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GateInfo>> *map_gates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GateInfo>> *>(VT_MAP_GATES);
  }
  flatbuffers::Vector<flatbuffers::Offset<GateInfo>> *mutable_map_gates() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<GateInfo>> *>(VT_MAP_GATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyField<int32_t>(verifier, VT_MAP_ID) &&
           VerifyField<int32_t>(verifier, VT_MAP_TYPE) &&
           VerifyOffset(verifier, VT_MAP_GATES) &&
           verifier.Verify(map_gates()) &&
           verifier.VerifyVectorOfTables(map_gates()) &&
           verifier.EndTable();
  }
  MapDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(MapData::VT_ENTITY_ID, entity_id);
  }
  void add_map_id(int32_t map_id) {
    fbb_.AddElement<int32_t>(MapData::VT_MAP_ID, map_id, 0);
  }
  void add_map_type(ProtocolCS::MapType map_type) {
    fbb_.AddElement<int32_t>(MapData::VT_MAP_TYPE, static_cast<int32_t>(map_type), 0);
  }
  void add_map_gates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GateInfo>>> map_gates) {
    fbb_.AddOffset(MapData::VT_MAP_GATES, map_gates);
  }
  MapDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapDataBuilder &operator=(const MapDataBuilder &);
  flatbuffers::Offset<MapData> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<MapData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapData> CreateMapData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    int32_t map_id = 0,
    ProtocolCS::MapType map_type = ProtocolCS::MapType::NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GateInfo>>> map_gates = 0) {
  MapDataBuilder builder_(_fbb);
  builder_.add_map_gates(map_gates);
  builder_.add_map_type(map_type);
  builder_.add_map_id(map_id);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapData> CreateMapDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    int32_t map_id = 0,
    ProtocolCS::MapType map_type = ProtocolCS::MapType::NONE,
    const std::vector<flatbuffers::Offset<GateInfo>> *map_gates = nullptr) {
  return ProtocolCS::World::CreateMapData(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      map_id,
      map_type,
      map_gates ? _fbb.CreateVector<flatbuffers::Offset<GateInfo>>(*map_gates) : 0);
}

flatbuffers::Offset<MapData> CreateMapData(flatbuffers::FlatBufferBuilder &_fbb, const MapDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActorT : public flatbuffers::NativeTable {
  typedef Actor TableType;
  ActorTypeUnion entity;
  ActorT() {
  }
};

struct Actor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActorT NativeTableType;
  enum {
    VT_ENTITY_TYPE = 4,
    VT_ENTITY = 6
  };
  ActorType entity_type() const {
    return static_cast<ActorType>(GetField<uint8_t>(VT_ENTITY_TYPE, 0));
  }
  bool mutate_entity_type(ActorType _entity_type) {
    return SetField<uint8_t>(VT_ENTITY_TYPE, static_cast<uint8_t>(_entity_type), 0);
  }
  const void *entity() const {
    return GetPointer<const void *>(VT_ENTITY);
  }
  template<typename T> const T *entity_as() const;
  const Hero *entity_as_Hero() const {
    return entity_type() == ActorType::Hero ? static_cast<const Hero *>(entity()) : nullptr;
  }
  const Monster *entity_as_Monster() const {
    return entity_type() == ActorType::Monster ? static_cast<const Monster *>(entity()) : nullptr;
  }
  void *mutable_entity() {
    return GetPointer<void *>(VT_ENTITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENTITY_TYPE) &&
           VerifyOffset(verifier, VT_ENTITY) &&
           VerifyActorType(verifier, entity(), entity_type()) &&
           verifier.EndTable();
  }
  ActorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Actor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Hero *Actor::entity_as<Hero>() const {
  return entity_as_Hero();
}

template<> inline const Monster *Actor::entity_as<Monster>() const {
  return entity_as_Monster();
}

struct ActorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_type(ActorType entity_type) {
    fbb_.AddElement<uint8_t>(Actor::VT_ENTITY_TYPE, static_cast<uint8_t>(entity_type), 0);
  }
  void add_entity(flatbuffers::Offset<void> entity) {
    fbb_.AddOffset(Actor::VT_ENTITY, entity);
  }
  ActorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActorBuilder &operator=(const ActorBuilder &);
  flatbuffers::Offset<Actor> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Actor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Actor> CreateActor(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActorType entity_type = ActorType::NONE,
    flatbuffers::Offset<void> entity = 0) {
  ActorBuilder builder_(_fbb);
  builder_.add_entity(entity);
  builder_.add_entity_type(entity_type);
  return builder_.Finish();
}

flatbuffers::Offset<Actor> CreateActor(flatbuffers::FlatBufferBuilder &_fbb, const ActorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoveActionInfoT : public flatbuffers::NativeTable {
  typedef MoveActionInfo TableType;
  std::string entity_id;
  std::unique_ptr<ProtocolCS::Vec3> position;
  float rotation;
  std::unique_ptr<ProtocolCS::Vec3> velocity;
  MoveActionInfoT()
      : rotation(0.0f) {
  }
};

struct MoveActionInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MoveActionInfoT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_POSITION = 6,
    VT_ROTATION = 8,
    VT_VELOCITY = 10
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  const ProtocolCS::Vec3 *position() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_POSITION);
  }
  ProtocolCS::Vec3 *mutable_position() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_POSITION);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool mutate_rotation(float _rotation) {
    return SetField<float>(VT_ROTATION, _rotation, 0.0f);
  }
  const ProtocolCS::Vec3 *velocity() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_VELOCITY);
  }
  ProtocolCS::Vec3 *mutable_velocity() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_VELOCITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_POSITION) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_VELOCITY) &&
           verifier.EndTable();
  }
  MoveActionInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoveActionInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MoveActionInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveActionInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoveActionInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(MoveActionInfo::VT_ENTITY_ID, entity_id);
  }
  void add_position(const ProtocolCS::Vec3 *position) {
    fbb_.AddStruct(MoveActionInfo::VT_POSITION, position);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(MoveActionInfo::VT_ROTATION, rotation, 0.0f);
  }
  void add_velocity(const ProtocolCS::Vec3 *velocity) {
    fbb_.AddStruct(MoveActionInfo::VT_VELOCITY, velocity);
  }
  MoveActionInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveActionInfoBuilder &operator=(const MoveActionInfoBuilder &);
  flatbuffers::Offset<MoveActionInfo> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<MoveActionInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveActionInfo> CreateMoveActionInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    const ProtocolCS::Vec3 *position = 0,
    float rotation = 0.0f,
    const ProtocolCS::Vec3 *velocity = 0) {
  MoveActionInfoBuilder builder_(_fbb);
  builder_.add_velocity(velocity);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MoveActionInfo> CreateMoveActionInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    const ProtocolCS::Vec3 *position = 0,
    float rotation = 0.0f,
    const ProtocolCS::Vec3 *velocity = 0) {
  return ProtocolCS::World::CreateMoveActionInfo(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      position,
      rotation,
      velocity);
}

flatbuffers::Offset<MoveActionInfo> CreateMoveActionInfo(flatbuffers::FlatBufferBuilder &_fbb, const MoveActionInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SkillActionInfoT : public flatbuffers::NativeTable {
  typedef SkillActionInfo TableType;
  std::string entity_id;
  int32_t skill_id;
  std::vector<std::string> targets;
  float rotation;
  SkillActionInfoT()
      : skill_id(0),
        rotation(0.0f) {
  }
};

struct SkillActionInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkillActionInfoT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_SKILL_ID = 6,
    VT_TARGETS = 8,
    VT_ROTATION = 10
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  int32_t skill_id() const {
    return GetField<int32_t>(VT_SKILL_ID, 0);
  }
  bool mutate_skill_id(int32_t _skill_id) {
    return SetField<int32_t>(VT_SKILL_ID, _skill_id, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *targets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TARGETS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_targets() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TARGETS);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool mutate_rotation(float _rotation) {
    return SetField<float>(VT_ROTATION, _rotation, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyField<int32_t>(verifier, VT_SKILL_ID) &&
           VerifyOffset(verifier, VT_TARGETS) &&
           verifier.Verify(targets()) &&
           verifier.VerifyVectorOfStrings(targets()) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
  SkillActionInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SkillActionInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SkillActionInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkillActionInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkillActionInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(SkillActionInfo::VT_ENTITY_ID, entity_id);
  }
  void add_skill_id(int32_t skill_id) {
    fbb_.AddElement<int32_t>(SkillActionInfo::VT_SKILL_ID, skill_id, 0);
  }
  void add_targets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> targets) {
    fbb_.AddOffset(SkillActionInfo::VT_TARGETS, targets);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(SkillActionInfo::VT_ROTATION, rotation, 0.0f);
  }
  SkillActionInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkillActionInfoBuilder &operator=(const SkillActionInfoBuilder &);
  flatbuffers::Offset<SkillActionInfo> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<SkillActionInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkillActionInfo> CreateSkillActionInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    int32_t skill_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> targets = 0,
    float rotation = 0.0f) {
  SkillActionInfoBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_targets(targets);
  builder_.add_skill_id(skill_id);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<SkillActionInfo> CreateSkillActionInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    int32_t skill_id = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *targets = nullptr,
    float rotation = 0.0f) {
  return ProtocolCS::World::CreateSkillActionInfo(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      skill_id,
      targets ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*targets) : 0,
      rotation);
}

flatbuffers::Offset<SkillActionInfo> CreateSkillActionInfo(flatbuffers::FlatBufferBuilder &_fbb, const SkillActionInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DamageInfoT : public flatbuffers::NativeTable {
  typedef DamageInfo TableType;
  std::string entity_id;
  int32_t damage;
  DamageInfoT()
      : damage(0) {
  }
};

struct DamageInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DamageInfoT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_DAMAGE = 6
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  int32_t damage() const {
    return GetField<int32_t>(VT_DAMAGE, 0);
  }
  bool mutate_damage(int32_t _damage) {
    return SetField<int32_t>(VT_DAMAGE, _damage, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyField<int32_t>(verifier, VT_DAMAGE) &&
           verifier.EndTable();
  }
  DamageInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DamageInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DamageInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DamageInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DamageInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(DamageInfo::VT_ENTITY_ID, entity_id);
  }
  void add_damage(int32_t damage) {
    fbb_.AddElement<int32_t>(DamageInfo::VT_DAMAGE, damage, 0);
  }
  DamageInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DamageInfoBuilder &operator=(const DamageInfoBuilder &);
  flatbuffers::Offset<DamageInfo> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<DamageInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<DamageInfo> CreateDamageInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    int32_t damage = 0) {
  DamageInfoBuilder builder_(_fbb);
  builder_.add_damage(damage);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DamageInfo> CreateDamageInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    int32_t damage = 0) {
  return ProtocolCS::World::CreateDamageInfo(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      damage);
}

flatbuffers::Offset<DamageInfo> CreateDamageInfo(flatbuffers::FlatBufferBuilder &_fbb, const DamageInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StateInfoT : public flatbuffers::NativeTable {
  typedef StateInfo TableType;
  std::string entity_id;
  StateType state;
  StateInfoT()
      : state(StateType::NONE) {
  }
};

struct StateInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateInfoT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_STATE = 6
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  StateType state() const {
    return static_cast<StateType>(GetField<int32_t>(VT_STATE, 0));
  }
  bool mutate_state(StateType _state) {
    return SetField<int32_t>(VT_STATE, static_cast<int32_t>(_state), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
  StateInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StateInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StateInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StateInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StateInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(StateInfo::VT_ENTITY_ID, entity_id);
  }
  void add_state(StateType state) {
    fbb_.AddElement<int32_t>(StateInfo::VT_STATE, static_cast<int32_t>(state), 0);
  }
  StateInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateInfoBuilder &operator=(const StateInfoBuilder &);
  flatbuffers::Offset<StateInfo> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<StateInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<StateInfo> CreateStateInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    StateType state = StateType::NONE) {
  StateInfoBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<StateInfo> CreateStateInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    StateType state = StateType::NONE) {
  return ProtocolCS::World::CreateStateInfo(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      state);
}

flatbuffers::Offset<StateInfo> CreateStateInfo(flatbuffers::FlatBufferBuilder &_fbb, const StateInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttributeInfoT : public flatbuffers::NativeTable {
  typedef AttributeInfo TableType;
  std::string entity_id;
  int32_t max_hp;
  int32_t hp;
  int32_t max_mp;
  int32_t mp;
  AttributeInfoT()
      : max_hp(0),
        hp(0),
        max_mp(0),
        mp(0) {
  }
};

struct AttributeInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeInfoT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_MAX_HP = 6,
    VT_HP = 8,
    VT_MAX_MP = 10,
    VT_MP = 12
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  int32_t max_hp() const {
    return GetField<int32_t>(VT_MAX_HP, 0);
  }
  bool mutate_max_hp(int32_t _max_hp) {
    return SetField<int32_t>(VT_MAX_HP, _max_hp, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  bool mutate_hp(int32_t _hp) {
    return SetField<int32_t>(VT_HP, _hp, 0);
  }
  int32_t max_mp() const {
    return GetField<int32_t>(VT_MAX_MP, 0);
  }
  bool mutate_max_mp(int32_t _max_mp) {
    return SetField<int32_t>(VT_MAX_MP, _max_mp, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  bool mutate_mp(int32_t _mp) {
    return SetField<int32_t>(VT_MP, _mp, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyField<int32_t>(verifier, VT_MAX_HP) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MAX_MP) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           verifier.EndTable();
  }
  AttributeInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttributeInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AttributeInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttributeInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttributeInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(AttributeInfo::VT_ENTITY_ID, entity_id);
  }
  void add_max_hp(int32_t max_hp) {
    fbb_.AddElement<int32_t>(AttributeInfo::VT_MAX_HP, max_hp, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(AttributeInfo::VT_HP, hp, 0);
  }
  void add_max_mp(int32_t max_mp) {
    fbb_.AddElement<int32_t>(AttributeInfo::VT_MAX_MP, max_mp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(AttributeInfo::VT_MP, mp, 0);
  }
  AttributeInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeInfoBuilder &operator=(const AttributeInfoBuilder &);
  flatbuffers::Offset<AttributeInfo> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<AttributeInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeInfo> CreateAttributeInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0) {
  AttributeInfoBuilder builder_(_fbb);
  builder_.add_mp(mp);
  builder_.add_max_mp(max_mp);
  builder_.add_hp(hp);
  builder_.add_max_hp(max_hp);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttributeInfo> CreateAttributeInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0) {
  return ProtocolCS::World::CreateAttributeInfo(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      max_hp,
      hp,
      max_mp,
      mp);
}

flatbuffers::Offset<AttributeInfo> CreateAttributeInfo(flatbuffers::FlatBufferBuilder &_fbb, const AttributeInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_LoginT : public flatbuffers::NativeTable {
  typedef Request_Login TableType;
  std::string credential;
  int32_t hero_uid;
  Request_LoginT()
      : hero_uid(0) {
  }
};

struct Request_Login FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_LoginT NativeTableType;
  enum {
    VT_CREDENTIAL = 4,
    VT_HERO_UID = 6
  };
  const flatbuffers::String *credential() const {
    return GetPointer<const flatbuffers::String *>(VT_CREDENTIAL);
  }
  flatbuffers::String *mutable_credential() {
    return GetPointer<flatbuffers::String *>(VT_CREDENTIAL);
  }
  int32_t hero_uid() const {
    return GetField<int32_t>(VT_HERO_UID, 0);
  }
  bool mutate_hero_uid(int32_t _hero_uid) {
    return SetField<int32_t>(VT_HERO_UID, _hero_uid, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CREDENTIAL) &&
           verifier.Verify(credential()) &&
           VerifyField<int32_t>(verifier, VT_HERO_UID) &&
           verifier.EndTable();
  }
  Request_LoginT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_LoginT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Login> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_LoginBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_credential(flatbuffers::Offset<flatbuffers::String> credential) {
    fbb_.AddOffset(Request_Login::VT_CREDENTIAL, credential);
  }
  void add_hero_uid(int32_t hero_uid) {
    fbb_.AddElement<int32_t>(Request_Login::VT_HERO_UID, hero_uid, 0);
  }
  Request_LoginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_LoginBuilder &operator=(const Request_LoginBuilder &);
  flatbuffers::Offset<Request_Login> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Request_Login>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Login> CreateRequest_Login(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> credential = 0,
    int32_t hero_uid = 0) {
  Request_LoginBuilder builder_(_fbb);
  builder_.add_hero_uid(hero_uid);
  builder_.add_credential(credential);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Login> CreateRequest_LoginDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *credential = nullptr,
    int32_t hero_uid = 0) {
  return ProtocolCS::World::CreateRequest_Login(
      _fbb,
      credential ? _fbb.CreateString(credential) : 0,
      hero_uid);
}

flatbuffers::Offset<Request_Login> CreateRequest_Login(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_LoginSuccessT : public flatbuffers::NativeTable {
  typedef Reply_LoginSuccess TableType;
  std::unique_ptr<HeroT> hero;
  Reply_LoginSuccessT() {
  }
};

struct Reply_LoginSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_LoginSuccessT NativeTableType;
  enum {
    VT_HERO = 4
  };
  const Hero *hero() const {
    return GetPointer<const Hero *>(VT_HERO);
  }
  Hero *mutable_hero() {
    return GetPointer<Hero *>(VT_HERO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HERO) &&
           verifier.VerifyTable(hero()) &&
           verifier.EndTable();
  }
  Reply_LoginSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_LoginSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_LoginSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_LoginSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hero(flatbuffers::Offset<Hero> hero) {
    fbb_.AddOffset(Reply_LoginSuccess::VT_HERO, hero);
  }
  Reply_LoginSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_LoginSuccessBuilder &operator=(const Reply_LoginSuccessBuilder &);
  flatbuffers::Offset<Reply_LoginSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_LoginSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Hero> hero = 0) {
  Reply_LoginSuccessBuilder builder_(_fbb);
  builder_.add_hero(hero);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_LoginFailedT : public flatbuffers::NativeTable {
  typedef Reply_LoginFailed TableType;
  ProtocolCS::ErrorCode error_code;
  Reply_LoginFailedT()
      : error_code(ProtocolCS::ErrorCode::OK) {
  }
};

struct Reply_LoginFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_LoginFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ProtocolCS::ErrorCode error_code() const {
    return static_cast<ProtocolCS::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ProtocolCS::ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_LoginFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_LoginFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_LoginFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_LoginFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ProtocolCS::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_LoginFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_LoginFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_LoginFailedBuilder &operator=(const Reply_LoginFailedBuilder &);
  flatbuffers::Offset<Reply_LoginFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_LoginFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_LoginFailed> CreateReply_LoginFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::ErrorCode error_code = ProtocolCS::ErrorCode::OK) {
  Reply_LoginFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_LoginFailed> CreateReply_LoginFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_LoadFinishT : public flatbuffers::NativeTable {
  typedef Notify_LoadFinish TableType;
  Notify_LoadFinishT() {
  }
};

struct Notify_LoadFinish FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_LoadFinishT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Notify_LoadFinishT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_LoadFinishT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_LoadFinish> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_LoadFinishT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_LoadFinishBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Notify_LoadFinishBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_LoadFinishBuilder &operator=(const Notify_LoadFinishBuilder &);
  flatbuffers::Offset<Notify_LoadFinish> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Notify_LoadFinish>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_LoadFinish> CreateNotify_LoadFinish(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Notify_LoadFinishBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Notify_LoadFinish> CreateNotify_LoadFinish(flatbuffers::FlatBufferBuilder &_fbb, const Notify_LoadFinishT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_EnterSuccessT : public flatbuffers::NativeTable {
  typedef Notify_EnterSuccess TableType;
  std::unique_ptr<HeroT> hero;
  std::unique_ptr<MapDataT> map_data;
  Notify_EnterSuccessT() {
  }
};

struct Notify_EnterSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_EnterSuccessT NativeTableType;
  enum {
    VT_HERO = 4,
    VT_MAP_DATA = 6
  };
  const Hero *hero() const {
    return GetPointer<const Hero *>(VT_HERO);
  }
  Hero *mutable_hero() {
    return GetPointer<Hero *>(VT_HERO);
  }
  const MapData *map_data() const {
    return GetPointer<const MapData *>(VT_MAP_DATA);
  }
  MapData *mutable_map_data() {
    return GetPointer<MapData *>(VT_MAP_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HERO) &&
           verifier.VerifyTable(hero()) &&
           VerifyOffset(verifier, VT_MAP_DATA) &&
           verifier.VerifyTable(map_data()) &&
           verifier.EndTable();
  }
  Notify_EnterSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_EnterSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_EnterSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_EnterSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hero(flatbuffers::Offset<Hero> hero) {
    fbb_.AddOffset(Notify_EnterSuccess::VT_HERO, hero);
  }
  void add_map_data(flatbuffers::Offset<MapData> map_data) {
    fbb_.AddOffset(Notify_EnterSuccess::VT_MAP_DATA, map_data);
  }
  Notify_EnterSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_EnterSuccessBuilder &operator=(const Notify_EnterSuccessBuilder &);
  flatbuffers::Offset<Notify_EnterSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Notify_EnterSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_EnterSuccess> CreateNotify_EnterSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Hero> hero = 0,
    flatbuffers::Offset<MapData> map_data = 0) {
  Notify_EnterSuccessBuilder builder_(_fbb);
  builder_.add_map_data(map_data);
  builder_.add_hero(hero);
  return builder_.Finish();
}

flatbuffers::Offset<Notify_EnterSuccess> CreateNotify_EnterSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_EnterFailedT : public flatbuffers::NativeTable {
  typedef Notify_EnterFailed TableType;
  ProtocolCS::ErrorCode error_code;
  Notify_EnterFailedT()
      : error_code(ProtocolCS::ErrorCode::OK) {
  }
};

struct Notify_EnterFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_EnterFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ProtocolCS::ErrorCode error_code() const {
    return static_cast<ProtocolCS::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ProtocolCS::ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Notify_EnterFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_EnterFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_EnterFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_EnterFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ProtocolCS::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Notify_EnterFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Notify_EnterFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_EnterFailedBuilder &operator=(const Notify_EnterFailedBuilder &);
  flatbuffers::Offset<Notify_EnterFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Notify_EnterFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_EnterFailed> CreateNotify_EnterFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::ErrorCode error_code = ProtocolCS::ErrorCode::OK) {
  Notify_EnterFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Notify_EnterFailed> CreateNotify_EnterFailed(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_ActionMoveT : public flatbuffers::NativeTable {
  typedef Request_ActionMove TableType;
  std::unique_ptr<ProtocolCS::Vec3> position;
  float rotation;
  std::unique_ptr<ProtocolCS::Vec3> velocity;
  Request_ActionMoveT()
      : rotation(0.0f) {
  }
};

struct Request_ActionMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_ActionMoveT NativeTableType;
  enum {
    VT_POSITION = 4,
    VT_ROTATION = 6,
    VT_VELOCITY = 8
  };
  const ProtocolCS::Vec3 *position() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_POSITION);
  }
  ProtocolCS::Vec3 *mutable_position() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_POSITION);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool mutate_rotation(float _rotation) {
    return SetField<float>(VT_ROTATION, _rotation, 0.0f);
  }
  const ProtocolCS::Vec3 *velocity() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_VELOCITY);
  }
  ProtocolCS::Vec3 *mutable_velocity() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_VELOCITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_POSITION) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_VELOCITY) &&
           verifier.EndTable();
  }
  Request_ActionMoveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_ActionMoveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_ActionMove> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_ActionMoveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_ActionMoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const ProtocolCS::Vec3 *position) {
    fbb_.AddStruct(Request_ActionMove::VT_POSITION, position);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(Request_ActionMove::VT_ROTATION, rotation, 0.0f);
  }
  void add_velocity(const ProtocolCS::Vec3 *velocity) {
    fbb_.AddStruct(Request_ActionMove::VT_VELOCITY, velocity);
  }
  Request_ActionMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_ActionMoveBuilder &operator=(const Request_ActionMoveBuilder &);
  flatbuffers::Offset<Request_ActionMove> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Request_ActionMove>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_ActionMove> CreateRequest_ActionMove(
    flatbuffers::FlatBufferBuilder &_fbb,
    const ProtocolCS::Vec3 *position = 0,
    float rotation = 0.0f,
    const ProtocolCS::Vec3 *velocity = 0) {
  Request_ActionMoveBuilder builder_(_fbb);
  builder_.add_velocity(velocity);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  return builder_.Finish();
}

flatbuffers::Offset<Request_ActionMove> CreateRequest_ActionMove(flatbuffers::FlatBufferBuilder &_fbb, const Request_ActionMoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_ActionSkillT : public flatbuffers::NativeTable {
  typedef Request_ActionSkill TableType;
  int32_t skill;
  std::vector<std::string> targets;
  float rotation;
  Request_ActionSkillT()
      : skill(0),
        rotation(0.0f) {
  }
};

struct Request_ActionSkill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_ActionSkillT NativeTableType;
  enum {
    VT_SKILL = 4,
    VT_TARGETS = 6,
    VT_ROTATION = 8
  };
  int32_t skill() const {
    return GetField<int32_t>(VT_SKILL, 0);
  }
  bool mutate_skill(int32_t _skill) {
    return SetField<int32_t>(VT_SKILL, _skill, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *targets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TARGETS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_targets() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TARGETS);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool mutate_rotation(float _rotation) {
    return SetField<float>(VT_ROTATION, _rotation, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SKILL) &&
           VerifyOffset(verifier, VT_TARGETS) &&
           verifier.Verify(targets()) &&
           verifier.VerifyVectorOfStrings(targets()) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
  Request_ActionSkillT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_ActionSkillT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_ActionSkill> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_ActionSkillT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_ActionSkillBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skill(int32_t skill) {
    fbb_.AddElement<int32_t>(Request_ActionSkill::VT_SKILL, skill, 0);
  }
  void add_targets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> targets) {
    fbb_.AddOffset(Request_ActionSkill::VT_TARGETS, targets);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(Request_ActionSkill::VT_ROTATION, rotation, 0.0f);
  }
  Request_ActionSkillBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_ActionSkillBuilder &operator=(const Request_ActionSkillBuilder &);
  flatbuffers::Offset<Request_ActionSkill> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Request_ActionSkill>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_ActionSkill> CreateRequest_ActionSkill(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t skill = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> targets = 0,
    float rotation = 0.0f) {
  Request_ActionSkillBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_targets(targets);
  builder_.add_skill(skill);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_ActionSkill> CreateRequest_ActionSkillDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t skill = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *targets = nullptr,
    float rotation = 0.0f) {
  return ProtocolCS::World::CreateRequest_ActionSkill(
      _fbb,
      skill,
      targets ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*targets) : 0,
      rotation);
}

flatbuffers::Offset<Request_ActionSkill> CreateRequest_ActionSkill(flatbuffers::FlatBufferBuilder &_fbb, const Request_ActionSkillT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_RespawnT : public flatbuffers::NativeTable {
  typedef Request_Respawn TableType;
  Request_RespawnT() {
  }
};

struct Request_Respawn FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_RespawnT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Request_RespawnT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_RespawnT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Respawn> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_RespawnT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_RespawnBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Request_RespawnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_RespawnBuilder &operator=(const Request_RespawnBuilder &);
  flatbuffers::Offset<Request_Respawn> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Request_Respawn>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Respawn> CreateRequest_Respawn(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Request_RespawnBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Request_Respawn> CreateRequest_Respawn(flatbuffers::FlatBufferBuilder &_fbb, const Request_RespawnT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_AppearT : public flatbuffers::NativeTable {
  typedef Notify_Appear TableType;
  std::unique_ptr<ActorT> entity;
  Notify_AppearT() {
  }
};

struct Notify_Appear FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_AppearT NativeTableType;
  enum {
    VT_ENTITY = 4
  };
  const Actor *entity() const {
    return GetPointer<const Actor *>(VT_ENTITY);
  }
  Actor *mutable_entity() {
    return GetPointer<Actor *>(VT_ENTITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY) &&
           verifier.VerifyTable(entity()) &&
           verifier.EndTable();
  }
  Notify_AppearT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_AppearT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_Appear> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AppearT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_AppearBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity(flatbuffers::Offset<Actor> entity) {
    fbb_.AddOffset(Notify_Appear::VT_ENTITY, entity);
  }
  Notify_AppearBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_AppearBuilder &operator=(const Notify_AppearBuilder &);
  flatbuffers::Offset<Notify_Appear> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Notify_Appear>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_Appear> CreateNotify_Appear(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Actor> entity = 0) {
  Notify_AppearBuilder builder_(_fbb);
  builder_.add_entity(entity);
  return builder_.Finish();
}

flatbuffers::Offset<Notify_Appear> CreateNotify_Appear(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AppearT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_DisappearT : public flatbuffers::NativeTable {
  typedef Notify_Disappear TableType;
  std::string entity_id;
  Notify_DisappearT() {
  }
};

struct Notify_Disappear FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_DisappearT NativeTableType;
  enum {
    VT_ENTITY_ID = 4
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           verifier.EndTable();
  }
  Notify_DisappearT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_DisappearT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_Disappear> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DisappearT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_DisappearBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(Notify_Disappear::VT_ENTITY_ID, entity_id);
  }
  Notify_DisappearBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_DisappearBuilder &operator=(const Notify_DisappearBuilder &);
  flatbuffers::Offset<Notify_Disappear> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Notify_Disappear>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_Disappear> CreateNotify_Disappear(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0) {
  Notify_DisappearBuilder builder_(_fbb);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notify_Disappear> CreateNotify_DisappearDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr) {
  return ProtocolCS::World::CreateNotify_Disappear(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0);
}

flatbuffers::Offset<Notify_Disappear> CreateNotify_Disappear(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DisappearT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_UpdateT : public flatbuffers::NativeTable {
  typedef Notify_Update TableType;
  std::string entity_id;
  UpdateTypeUnion update_data;
  Notify_UpdateT() {
  }
};

struct Notify_Update FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_UpdateT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_UPDATE_DATA_TYPE = 6,
    VT_UPDATE_DATA = 8
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  UpdateType update_data_type() const {
    return static_cast<UpdateType>(GetField<uint8_t>(VT_UPDATE_DATA_TYPE, 0));
  }
  bool mutate_update_data_type(UpdateType _update_data_type) {
    return SetField<uint8_t>(VT_UPDATE_DATA_TYPE, static_cast<uint8_t>(_update_data_type), 0);
  }
  const void *update_data() const {
    return GetPointer<const void *>(VT_UPDATE_DATA);
  }
  template<typename T> const T *update_data_as() const;
  const Actor *update_data_as_Actor() const {
    return update_data_type() == UpdateType::Actor ? static_cast<const Actor *>(update_data()) : nullptr;
  }
  const MoveActionInfo *update_data_as_MoveActionInfo() const {
    return update_data_type() == UpdateType::MoveActionInfo ? static_cast<const MoveActionInfo *>(update_data()) : nullptr;
  }
  const SkillActionInfo *update_data_as_SkillActionInfo() const {
    return update_data_type() == UpdateType::SkillActionInfo ? static_cast<const SkillActionInfo *>(update_data()) : nullptr;
  }
  const DamageInfo *update_data_as_DamageInfo() const {
    return update_data_type() == UpdateType::DamageInfo ? static_cast<const DamageInfo *>(update_data()) : nullptr;
  }
  const StateInfo *update_data_as_StateInfo() const {
    return update_data_type() == UpdateType::StateInfo ? static_cast<const StateInfo *>(update_data()) : nullptr;
  }
  const AttributeInfo *update_data_as_AttributeInfo() const {
    return update_data_type() == UpdateType::AttributeInfo ? static_cast<const AttributeInfo *>(update_data()) : nullptr;
  }
  void *mutable_update_data() {
    return GetPointer<void *>(VT_UPDATE_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_DATA_TYPE) &&
           VerifyOffset(verifier, VT_UPDATE_DATA) &&
           VerifyUpdateType(verifier, update_data(), update_data_type()) &&
           verifier.EndTable();
  }
  Notify_UpdateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_UpdateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_Update> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UpdateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Actor *Notify_Update::update_data_as<Actor>() const {
  return update_data_as_Actor();
}

template<> inline const MoveActionInfo *Notify_Update::update_data_as<MoveActionInfo>() const {
  return update_data_as_MoveActionInfo();
}

template<> inline const SkillActionInfo *Notify_Update::update_data_as<SkillActionInfo>() const {
  return update_data_as_SkillActionInfo();
}

template<> inline const DamageInfo *Notify_Update::update_data_as<DamageInfo>() const {
  return update_data_as_DamageInfo();
}

template<> inline const StateInfo *Notify_Update::update_data_as<StateInfo>() const {
  return update_data_as_StateInfo();
}

template<> inline const AttributeInfo *Notify_Update::update_data_as<AttributeInfo>() const {
  return update_data_as_AttributeInfo();
}

struct Notify_UpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(Notify_Update::VT_ENTITY_ID, entity_id);
  }
  void add_update_data_type(UpdateType update_data_type) {
    fbb_.AddElement<uint8_t>(Notify_Update::VT_UPDATE_DATA_TYPE, static_cast<uint8_t>(update_data_type), 0);
  }
  void add_update_data(flatbuffers::Offset<void> update_data) {
    fbb_.AddOffset(Notify_Update::VT_UPDATE_DATA, update_data);
  }
  Notify_UpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_UpdateBuilder &operator=(const Notify_UpdateBuilder &);
  flatbuffers::Offset<Notify_Update> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Notify_Update>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_Update> CreateNotify_Update(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    UpdateType update_data_type = UpdateType::NONE,
    flatbuffers::Offset<void> update_data = 0) {
  Notify_UpdateBuilder builder_(_fbb);
  builder_.add_update_data(update_data);
  builder_.add_entity_id(entity_id);
  builder_.add_update_data_type(update_data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notify_Update> CreateNotify_UpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    UpdateType update_data_type = UpdateType::NONE,
    flatbuffers::Offset<void> update_data = 0) {
  return ProtocolCS::World::CreateNotify_Update(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      update_data_type,
      update_data);
}

flatbuffers::Offset<Notify_Update> CreateNotify_Update(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_EnterGateT : public flatbuffers::NativeTable {
  typedef Request_EnterGate TableType;
  int32_t gate_uid;
  Request_EnterGateT()
      : gate_uid(0) {
  }
};

struct Request_EnterGate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_EnterGateT NativeTableType;
  enum {
    VT_GATE_UID = 4
  };
  int32_t gate_uid() const {
    return GetField<int32_t>(VT_GATE_UID, 0);
  }
  bool mutate_gate_uid(int32_t _gate_uid) {
    return SetField<int32_t>(VT_GATE_UID, _gate_uid, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GATE_UID) &&
           verifier.EndTable();
  }
  Request_EnterGateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_EnterGateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_EnterGate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterGateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_EnterGateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gate_uid(int32_t gate_uid) {
    fbb_.AddElement<int32_t>(Request_EnterGate::VT_GATE_UID, gate_uid, 0);
  }
  Request_EnterGateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_EnterGateBuilder &operator=(const Request_EnterGateBuilder &);
  flatbuffers::Offset<Request_EnterGate> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Request_EnterGate>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_EnterGate> CreateRequest_EnterGate(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t gate_uid = 0) {
  Request_EnterGateBuilder builder_(_fbb);
  builder_.add_gate_uid(gate_uid);
  return builder_.Finish();
}

flatbuffers::Offset<Request_EnterGate> CreateRequest_EnterGate(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterGateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_EnterGateFailedT : public flatbuffers::NativeTable {
  typedef Reply_EnterGateFailed TableType;
  ProtocolCS::ErrorCode error_code;
  Reply_EnterGateFailedT()
      : error_code(ProtocolCS::ErrorCode::OK) {
  }
};

struct Reply_EnterGateFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_EnterGateFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ProtocolCS::ErrorCode error_code() const {
    return static_cast<ProtocolCS::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ProtocolCS::ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_EnterGateFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_EnterGateFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_EnterGateFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterGateFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_EnterGateFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ProtocolCS::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_EnterGateFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_EnterGateFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_EnterGateFailedBuilder &operator=(const Reply_EnterGateFailedBuilder &);
  flatbuffers::Offset<Reply_EnterGateFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_EnterGateFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_EnterGateFailed> CreateReply_EnterGateFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::ErrorCode error_code = ProtocolCS::ErrorCode::OK) {
  Reply_EnterGateFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_EnterGateFailed> CreateReply_EnterGateFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterGateFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace World

struct MessageRootT : public flatbuffers::NativeTable {
  typedef MessageRoot TableType;
  MessageTypeUnion message;
  MessageRootT() {
  }
};

struct MessageRoot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageRootT NativeTableType;
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  MessageType message_type() const {
    return static_cast<MessageType>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  bool mutate_message_type(MessageType _message_type) {
    return SetField<uint8_t>(VT_MESSAGE_TYPE, static_cast<uint8_t>(_message_type), 0);
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const ProtocolCS::Notify_UnauthedAccess *message_as_Notify_UnauthedAccess() const {
    return message_type() == MessageType::Notify_UnauthedAccess ? static_cast<const ProtocolCS::Notify_UnauthedAccess *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Request_Login *message_as_Login_Request_Login() const {
    return message_type() == MessageType::Login_Request_Login ? static_cast<const ProtocolCS::Login::Request_Login *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_LoginSuccess *message_as_Login_Reply_LoginSuccess() const {
    return message_type() == MessageType::Login_Reply_LoginSuccess ? static_cast<const ProtocolCS::Login::Reply_LoginSuccess *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_LoginFailed *message_as_Login_Reply_LoginFailed() const {
    return message_type() == MessageType::Login_Reply_LoginFailed ? static_cast<const ProtocolCS::Login::Reply_LoginFailed *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Request_Join *message_as_Login_Request_Join() const {
    return message_type() == MessageType::Login_Request_Join ? static_cast<const ProtocolCS::Login::Request_Join *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_JoinSuccess *message_as_Login_Reply_JoinSuccess() const {
    return message_type() == MessageType::Login_Reply_JoinSuccess ? static_cast<const ProtocolCS::Login::Reply_JoinSuccess *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_JoinFailed *message_as_Login_Reply_JoinFailed() const {
    return message_type() == MessageType::Login_Reply_JoinFailed ? static_cast<const ProtocolCS::Login::Reply_JoinFailed *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Request_HeroList *message_as_Login_Request_HeroList() const {
    return message_type() == MessageType::Login_Request_HeroList ? static_cast<const ProtocolCS::Login::Request_HeroList *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_HeroList *message_as_Login_Reply_HeroList() const {
    return message_type() == MessageType::Login_Reply_HeroList ? static_cast<const ProtocolCS::Login::Reply_HeroList *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Request_CreateHero *message_as_Login_Request_CreateHero() const {
    return message_type() == MessageType::Login_Request_CreateHero ? static_cast<const ProtocolCS::Login::Request_CreateHero *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_CreateHeroSuccess *message_as_Login_Reply_CreateHeroSuccess() const {
    return message_type() == MessageType::Login_Reply_CreateHeroSuccess ? static_cast<const ProtocolCS::Login::Reply_CreateHeroSuccess *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_CreateHeroFailed *message_as_Login_Reply_CreateHeroFailed() const {
    return message_type() == MessageType::Login_Reply_CreateHeroFailed ? static_cast<const ProtocolCS::Login::Reply_CreateHeroFailed *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Request_DeleteHero *message_as_Login_Request_DeleteHero() const {
    return message_type() == MessageType::Login_Request_DeleteHero ? static_cast<const ProtocolCS::Login::Request_DeleteHero *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_DeleteHeroSuccess *message_as_Login_Reply_DeleteHeroSuccess() const {
    return message_type() == MessageType::Login_Reply_DeleteHeroSuccess ? static_cast<const ProtocolCS::Login::Reply_DeleteHeroSuccess *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_DeleteHeroFailed *message_as_Login_Reply_DeleteHeroFailed() const {
    return message_type() == MessageType::Login_Reply_DeleteHeroFailed ? static_cast<const ProtocolCS::Login::Reply_DeleteHeroFailed *>(message()) : nullptr;
  }
  const ProtocolCS::World::Request_Login *message_as_World_Request_Login() const {
    return message_type() == MessageType::World_Request_Login ? static_cast<const ProtocolCS::World::Request_Login *>(message()) : nullptr;
  }
  const ProtocolCS::World::Reply_LoginSuccess *message_as_World_Reply_LoginSuccess() const {
    return message_type() == MessageType::World_Reply_LoginSuccess ? static_cast<const ProtocolCS::World::Reply_LoginSuccess *>(message()) : nullptr;
  }
  const ProtocolCS::World::Reply_LoginFailed *message_as_World_Reply_LoginFailed() const {
    return message_type() == MessageType::World_Reply_LoginFailed ? static_cast<const ProtocolCS::World::Reply_LoginFailed *>(message()) : nullptr;
  }
  const ProtocolCS::World::Notify_LoadFinish *message_as_World_Notify_LoadFinish() const {
    return message_type() == MessageType::World_Notify_LoadFinish ? static_cast<const ProtocolCS::World::Notify_LoadFinish *>(message()) : nullptr;
  }
  const ProtocolCS::World::Notify_EnterSuccess *message_as_World_Notify_EnterSuccess() const {
    return message_type() == MessageType::World_Notify_EnterSuccess ? static_cast<const ProtocolCS::World::Notify_EnterSuccess *>(message()) : nullptr;
  }
  const ProtocolCS::World::Notify_EnterFailed *message_as_World_Notify_EnterFailed() const {
    return message_type() == MessageType::World_Notify_EnterFailed ? static_cast<const ProtocolCS::World::Notify_EnterFailed *>(message()) : nullptr;
  }
  const ProtocolCS::World::Request_ActionMove *message_as_World_Request_ActionMove() const {
    return message_type() == MessageType::World_Request_ActionMove ? static_cast<const ProtocolCS::World::Request_ActionMove *>(message()) : nullptr;
  }
  const ProtocolCS::World::Request_ActionSkill *message_as_World_Request_ActionSkill() const {
    return message_type() == MessageType::World_Request_ActionSkill ? static_cast<const ProtocolCS::World::Request_ActionSkill *>(message()) : nullptr;
  }
  const ProtocolCS::World::Notify_Appear *message_as_World_Notify_Appear() const {
    return message_type() == MessageType::World_Notify_Appear ? static_cast<const ProtocolCS::World::Notify_Appear *>(message()) : nullptr;
  }
  const ProtocolCS::World::Notify_Disappear *message_as_World_Notify_Disappear() const {
    return message_type() == MessageType::World_Notify_Disappear ? static_cast<const ProtocolCS::World::Notify_Disappear *>(message()) : nullptr;
  }
  const ProtocolCS::World::Notify_Update *message_as_World_Notify_Update() const {
    return message_type() == MessageType::World_Notify_Update ? static_cast<const ProtocolCS::World::Notify_Update *>(message()) : nullptr;
  }
  const ProtocolCS::World::Request_Respawn *message_as_World_Request_Respawn() const {
    return message_type() == MessageType::World_Request_Respawn ? static_cast<const ProtocolCS::World::Request_Respawn *>(message()) : nullptr;
  }
  const ProtocolCS::World::Request_EnterGate *message_as_World_Request_EnterGate() const {
    return message_type() == MessageType::World_Request_EnterGate ? static_cast<const ProtocolCS::World::Request_EnterGate *>(message()) : nullptr;
  }
  const ProtocolCS::World::Reply_EnterGateFailed *message_as_World_Reply_EnterGateFailed() const {
    return message_type() == MessageType::World_Reply_EnterGateFailed ? static_cast<const ProtocolCS::World::Reply_EnterGateFailed *>(message()) : nullptr;
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessageType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
  MessageRootT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageRootT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MessageRoot> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageRootT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ProtocolCS::Notify_UnauthedAccess *MessageRoot::message_as<ProtocolCS::Notify_UnauthedAccess>() const {
  return message_as_Notify_UnauthedAccess();
}

template<> inline const ProtocolCS::Login::Request_Login *MessageRoot::message_as<ProtocolCS::Login::Request_Login>() const {
  return message_as_Login_Request_Login();
}

template<> inline const ProtocolCS::Login::Reply_LoginSuccess *MessageRoot::message_as<ProtocolCS::Login::Reply_LoginSuccess>() const {
  return message_as_Login_Reply_LoginSuccess();
}

template<> inline const ProtocolCS::Login::Reply_LoginFailed *MessageRoot::message_as<ProtocolCS::Login::Reply_LoginFailed>() const {
  return message_as_Login_Reply_LoginFailed();
}

template<> inline const ProtocolCS::Login::Request_Join *MessageRoot::message_as<ProtocolCS::Login::Request_Join>() const {
  return message_as_Login_Request_Join();
}

template<> inline const ProtocolCS::Login::Reply_JoinSuccess *MessageRoot::message_as<ProtocolCS::Login::Reply_JoinSuccess>() const {
  return message_as_Login_Reply_JoinSuccess();
}

template<> inline const ProtocolCS::Login::Reply_JoinFailed *MessageRoot::message_as<ProtocolCS::Login::Reply_JoinFailed>() const {
  return message_as_Login_Reply_JoinFailed();
}

template<> inline const ProtocolCS::Login::Request_HeroList *MessageRoot::message_as<ProtocolCS::Login::Request_HeroList>() const {
  return message_as_Login_Request_HeroList();
}

template<> inline const ProtocolCS::Login::Reply_HeroList *MessageRoot::message_as<ProtocolCS::Login::Reply_HeroList>() const {
  return message_as_Login_Reply_HeroList();
}

template<> inline const ProtocolCS::Login::Request_CreateHero *MessageRoot::message_as<ProtocolCS::Login::Request_CreateHero>() const {
  return message_as_Login_Request_CreateHero();
}

template<> inline const ProtocolCS::Login::Reply_CreateHeroSuccess *MessageRoot::message_as<ProtocolCS::Login::Reply_CreateHeroSuccess>() const {
  return message_as_Login_Reply_CreateHeroSuccess();
}

template<> inline const ProtocolCS::Login::Reply_CreateHeroFailed *MessageRoot::message_as<ProtocolCS::Login::Reply_CreateHeroFailed>() const {
  return message_as_Login_Reply_CreateHeroFailed();
}

template<> inline const ProtocolCS::Login::Request_DeleteHero *MessageRoot::message_as<ProtocolCS::Login::Request_DeleteHero>() const {
  return message_as_Login_Request_DeleteHero();
}

template<> inline const ProtocolCS::Login::Reply_DeleteHeroSuccess *MessageRoot::message_as<ProtocolCS::Login::Reply_DeleteHeroSuccess>() const {
  return message_as_Login_Reply_DeleteHeroSuccess();
}

template<> inline const ProtocolCS::Login::Reply_DeleteHeroFailed *MessageRoot::message_as<ProtocolCS::Login::Reply_DeleteHeroFailed>() const {
  return message_as_Login_Reply_DeleteHeroFailed();
}

template<> inline const ProtocolCS::World::Request_Login *MessageRoot::message_as<ProtocolCS::World::Request_Login>() const {
  return message_as_World_Request_Login();
}

template<> inline const ProtocolCS::World::Reply_LoginSuccess *MessageRoot::message_as<ProtocolCS::World::Reply_LoginSuccess>() const {
  return message_as_World_Reply_LoginSuccess();
}

template<> inline const ProtocolCS::World::Reply_LoginFailed *MessageRoot::message_as<ProtocolCS::World::Reply_LoginFailed>() const {
  return message_as_World_Reply_LoginFailed();
}

template<> inline const ProtocolCS::World::Notify_LoadFinish *MessageRoot::message_as<ProtocolCS::World::Notify_LoadFinish>() const {
  return message_as_World_Notify_LoadFinish();
}

template<> inline const ProtocolCS::World::Notify_EnterSuccess *MessageRoot::message_as<ProtocolCS::World::Notify_EnterSuccess>() const {
  return message_as_World_Notify_EnterSuccess();
}

template<> inline const ProtocolCS::World::Notify_EnterFailed *MessageRoot::message_as<ProtocolCS::World::Notify_EnterFailed>() const {
  return message_as_World_Notify_EnterFailed();
}

template<> inline const ProtocolCS::World::Request_ActionMove *MessageRoot::message_as<ProtocolCS::World::Request_ActionMove>() const {
  return message_as_World_Request_ActionMove();
}

template<> inline const ProtocolCS::World::Request_ActionSkill *MessageRoot::message_as<ProtocolCS::World::Request_ActionSkill>() const {
  return message_as_World_Request_ActionSkill();
}

template<> inline const ProtocolCS::World::Notify_Appear *MessageRoot::message_as<ProtocolCS::World::Notify_Appear>() const {
  return message_as_World_Notify_Appear();
}

template<> inline const ProtocolCS::World::Notify_Disappear *MessageRoot::message_as<ProtocolCS::World::Notify_Disappear>() const {
  return message_as_World_Notify_Disappear();
}

template<> inline const ProtocolCS::World::Notify_Update *MessageRoot::message_as<ProtocolCS::World::Notify_Update>() const {
  return message_as_World_Notify_Update();
}

template<> inline const ProtocolCS::World::Request_Respawn *MessageRoot::message_as<ProtocolCS::World::Request_Respawn>() const {
  return message_as_World_Request_Respawn();
}

template<> inline const ProtocolCS::World::Request_EnterGate *MessageRoot::message_as<ProtocolCS::World::Request_EnterGate>() const {
  return message_as_World_Request_EnterGate();
}

template<> inline const ProtocolCS::World::Reply_EnterGateFailed *MessageRoot::message_as<ProtocolCS::World::Reply_EnterGateFailed>() const {
  return message_as_World_Reply_EnterGateFailed();
}

struct MessageRootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(MessageType message_type) {
    fbb_.AddElement<uint8_t>(MessageRoot::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(MessageRoot::VT_MESSAGE, message);
  }
  MessageRootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageRootBuilder &operator=(const MessageRootBuilder &);
  flatbuffers::Offset<MessageRoot> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<MessageRoot>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageRoot> CreateMessageRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    MessageType message_type = MessageType::NONE,
    flatbuffers::Offset<void> message = 0) {
  MessageRootBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

flatbuffers::Offset<MessageRoot> CreateMessageRoot(flatbuffers::FlatBufferBuilder &_fbb, const MessageRootT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Notify_UnauthedAccessT *Notify_UnauthedAccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_UnauthedAccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_UnauthedAccess::UnPackTo(Notify_UnauthedAccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Notify_UnauthedAccess> Notify_UnauthedAccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_UnauthedAccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_UnauthedAccess> CreateNotify_UnauthedAccess(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return ProtocolCS::CreateNotify_UnauthedAccess(
      _fbb);
}

namespace Login {

inline HeroT *Hero::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HeroT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Hero::UnPackTo(HeroT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uid(); _o->uid = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
  { auto _e = level(); _o->level = _e; };
}

inline flatbuffers::Offset<Hero> Hero::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeroT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHero(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Hero> CreateHero(flatbuffers::FlatBufferBuilder &_fbb, const HeroT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _uid = _o->uid;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  auto _level = _o->level;
  return ProtocolCS::Login::CreateHero(
      _fbb,
      _uid,
      _name,
      _class_type,
      _level);
}

inline Request_LoginT *Request_Login::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_LoginT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_Login::UnPackTo(Request_LoginT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = user_name(); if (_e) _o->user_name = _e->str(); };
  { auto _e = password(); if (_e) _o->password = _e->str(); };
}

inline flatbuffers::Offset<Request_Login> Request_Login::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Login(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Login> CreateRequest_Login(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _user_name = _o->user_name.size() ? _fbb.CreateString(_o->user_name) : 0;
  auto _password = _o->password.size() ? _fbb.CreateString(_o->password) : 0;
  return ProtocolCS::Login::CreateRequest_Login(
      _fbb,
      _user_name,
      _password);
}

inline Reply_LoginSuccessT *Reply_LoginSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_LoginSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_LoginSuccess::UnPackTo(Reply_LoginSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = credential(); if (_e) _o->credential = _e->str(); };
}

inline flatbuffers::Offset<Reply_LoginSuccess> Reply_LoginSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_LoginSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _credential = _o->credential.size() ? _fbb.CreateString(_o->credential) : 0;
  return ProtocolCS::Login::CreateReply_LoginSuccess(
      _fbb,
      _credential);
}

inline Reply_LoginFailedT *Reply_LoginFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_LoginFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_LoginFailed::UnPackTo(Reply_LoginFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_LoginFailed> Reply_LoginFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_LoginFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_LoginFailed> CreateReply_LoginFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return ProtocolCS::Login::CreateReply_LoginFailed(
      _fbb,
      _error_code);
}

inline Request_JoinT *Request_Join::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_JoinT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_Join::UnPackTo(Request_JoinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = user_name(); if (_e) _o->user_name = _e->str(); };
  { auto _e = password(); if (_e) _o->password = _e->str(); };
}

inline flatbuffers::Offset<Request_Join> Request_Join::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_JoinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Join(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Join> CreateRequest_Join(flatbuffers::FlatBufferBuilder &_fbb, const Request_JoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _user_name = _o->user_name.size() ? _fbb.CreateString(_o->user_name) : 0;
  auto _password = _o->password.size() ? _fbb.CreateString(_o->password) : 0;
  return ProtocolCS::Login::CreateRequest_Join(
      _fbb,
      _user_name,
      _password);
}

inline Reply_JoinSuccessT *Reply_JoinSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_JoinSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_JoinSuccess::UnPackTo(Reply_JoinSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Reply_JoinSuccess> Reply_JoinSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_JoinSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_JoinSuccess> CreateReply_JoinSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return ProtocolCS::Login::CreateReply_JoinSuccess(
      _fbb);
}

inline Reply_JoinFailedT *Reply_JoinFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_JoinFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_JoinFailed::UnPackTo(Reply_JoinFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_JoinFailed> Reply_JoinFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_JoinFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_JoinFailed> CreateReply_JoinFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return ProtocolCS::Login::CreateReply_JoinFailed(
      _fbb,
      _error_code);
}

inline Request_HeroListT *Request_HeroList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_HeroListT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_HeroList::UnPackTo(Request_HeroListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Request_HeroList> Request_HeroList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_HeroListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_HeroList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_HeroList> CreateRequest_HeroList(flatbuffers::FlatBufferBuilder &_fbb, const Request_HeroListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return ProtocolCS::Login::CreateRequest_HeroList(
      _fbb);
}

inline Reply_HeroListT *Reply_HeroList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_HeroListT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_HeroList::UnPackTo(Reply_HeroListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = list(); if (_e) { _o->list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->list[_i] = std::unique_ptr<HeroT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Reply_HeroList> Reply_HeroList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_HeroListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_HeroList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_HeroList> CreateReply_HeroList(flatbuffers::FlatBufferBuilder &_fbb, const Reply_HeroListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _list = _o->list.size() ? _fbb.CreateVector<flatbuffers::Offset<Hero>>(_o->list.size(), [&](size_t i) { return CreateHero(_fbb, _o->list[i].get(), _rehasher); }) : 0;
  return ProtocolCS::Login::CreateReply_HeroList(
      _fbb,
      _list);
}

inline Request_CreateHeroT *Request_CreateHero::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_CreateHeroT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_CreateHero::UnPackTo(Request_CreateHeroT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
}

inline flatbuffers::Offset<Request_CreateHero> Request_CreateHero::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_CreateHeroT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_CreateHero(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_CreateHero> CreateRequest_CreateHero(flatbuffers::FlatBufferBuilder &_fbb, const Request_CreateHeroT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  return ProtocolCS::Login::CreateRequest_CreateHero(
      _fbb,
      _name,
      _class_type);
}

inline Reply_CreateHeroSuccessT *Reply_CreateHeroSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_CreateHeroSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_CreateHeroSuccess::UnPackTo(Reply_CreateHeroSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hero(); if (_e) _o->hero = std::unique_ptr<HeroT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Reply_CreateHeroSuccess> Reply_CreateHeroSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateHeroSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_CreateHeroSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_CreateHeroSuccess> CreateReply_CreateHeroSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateHeroSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _hero = _o->hero ? CreateHero(_fbb, _o->hero.get(), _rehasher) : 0;
  return ProtocolCS::Login::CreateReply_CreateHeroSuccess(
      _fbb,
      _hero);
}

inline Reply_CreateHeroFailedT *Reply_CreateHeroFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_CreateHeroFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_CreateHeroFailed::UnPackTo(Reply_CreateHeroFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_CreateHeroFailed> Reply_CreateHeroFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateHeroFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_CreateHeroFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_CreateHeroFailed> CreateReply_CreateHeroFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateHeroFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return ProtocolCS::Login::CreateReply_CreateHeroFailed(
      _fbb,
      _error_code);
}

inline Request_DeleteHeroT *Request_DeleteHero::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_DeleteHeroT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_DeleteHero::UnPackTo(Request_DeleteHeroT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hero_uid(); _o->hero_uid = _e; };
}

inline flatbuffers::Offset<Request_DeleteHero> Request_DeleteHero::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_DeleteHeroT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_DeleteHero(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_DeleteHero> CreateRequest_DeleteHero(flatbuffers::FlatBufferBuilder &_fbb, const Request_DeleteHeroT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _hero_uid = _o->hero_uid;
  return ProtocolCS::Login::CreateRequest_DeleteHero(
      _fbb,
      _hero_uid);
}

inline Reply_DeleteHeroSuccessT *Reply_DeleteHeroSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_DeleteHeroSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_DeleteHeroSuccess::UnPackTo(Reply_DeleteHeroSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hero_uid(); _o->hero_uid = _e; };
}

inline flatbuffers::Offset<Reply_DeleteHeroSuccess> Reply_DeleteHeroSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteHeroSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_DeleteHeroSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_DeleteHeroSuccess> CreateReply_DeleteHeroSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteHeroSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _hero_uid = _o->hero_uid;
  return ProtocolCS::Login::CreateReply_DeleteHeroSuccess(
      _fbb,
      _hero_uid);
}

inline Reply_DeleteHeroFailedT *Reply_DeleteHeroFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_DeleteHeroFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_DeleteHeroFailed::UnPackTo(Reply_DeleteHeroFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_DeleteHeroFailed> Reply_DeleteHeroFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteHeroFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_DeleteHeroFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_DeleteHeroFailed> CreateReply_DeleteHeroFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteHeroFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return ProtocolCS::Login::CreateReply_DeleteHeroFailed(
      _fbb,
      _error_code);
}

}  // namespace Login

namespace World {

inline HeroT *Hero::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HeroT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Hero::UnPackTo(HeroT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = uid(); _o->uid = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
  { auto _e = exp(); _o->exp = _e; };
  { auto _e = level(); _o->level = _e; };
  { auto _e = max_hp(); _o->max_hp = _e; };
  { auto _e = hp(); _o->hp = _e; };
  { auto _e = max_mp(); _o->max_mp = _e; };
  { auto _e = mp(); _o->mp = _e; };
  { auto _e = att(); _o->att = _e; };
  { auto _e = def(); _o->def = _e; };
  { auto _e = map_id(); _o->map_id = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
  { auto _e = rotation(); _o->rotation = _e; };
}

inline flatbuffers::Offset<Hero> Hero::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeroT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHero(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Hero> CreateHero(flatbuffers::FlatBufferBuilder &_fbb, const HeroT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _uid = _o->uid;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  auto _exp = _o->exp;
  auto _level = _o->level;
  auto _max_hp = _o->max_hp;
  auto _hp = _o->hp;
  auto _max_mp = _o->max_mp;
  auto _mp = _o->mp;
  auto _att = _o->att;
  auto _def = _o->def;
  auto _map_id = _o->map_id;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _rotation = _o->rotation;
  return ProtocolCS::World::CreateHero(
      _fbb,
      _entity_id,
      _uid,
      _name,
      _class_type,
      _exp,
      _level,
      _max_hp,
      _hp,
      _max_mp,
      _mp,
      _att,
      _def,
      _map_id,
      _pos,
      _rotation);
}

inline MonsterT *Monster::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MonsterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Monster::UnPackTo(MonsterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = uid(); _o->uid = _e; };
  { auto _e = type_id(); _o->type_id = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = max_hp(); _o->max_hp = _e; };
  { auto _e = hp(); _o->hp = _e; };
  { auto _e = max_mp(); _o->max_mp = _e; };
  { auto _e = mp(); _o->mp = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
  { auto _e = rotation(); _o->rotation = _e; };
}

inline flatbuffers::Offset<Monster> Monster::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMonster(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _uid = _o->uid;
  auto _type_id = _o->type_id;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _level = _o->level;
  auto _max_hp = _o->max_hp;
  auto _hp = _o->hp;
  auto _max_mp = _o->max_mp;
  auto _mp = _o->mp;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _rotation = _o->rotation;
  return ProtocolCS::World::CreateMonster(
      _fbb,
      _entity_id,
      _uid,
      _type_id,
      _name,
      _level,
      _max_hp,
      _hp,
      _max_mp,
      _mp,
      _pos,
      _rotation);
}

inline GateInfoT *GateInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GateInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GateInfo::UnPackTo(GateInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uid(); _o->uid = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
  { auto _e = map_type(); _o->map_type = _e; };
}

inline flatbuffers::Offset<GateInfo> GateInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GateInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGateInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GateInfo> CreateGateInfo(flatbuffers::FlatBufferBuilder &_fbb, const GateInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _uid = _o->uid;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _map_type = _o->map_type;
  return ProtocolCS::World::CreateGateInfo(
      _fbb,
      _uid,
      _pos,
      _map_type);
}

inline MapDataT *MapData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MapDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MapData::UnPackTo(MapDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = map_id(); _o->map_id = _e; };
  { auto _e = map_type(); _o->map_type = _e; };
  { auto _e = map_gates(); if (_e) { _o->map_gates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->map_gates[_i] = std::unique_ptr<GateInfoT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<MapData> MapData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapData> CreateMapData(flatbuffers::FlatBufferBuilder &_fbb, const MapDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _map_id = _o->map_id;
  auto _map_type = _o->map_type;
  auto _map_gates = _o->map_gates.size() ? _fbb.CreateVector<flatbuffers::Offset<GateInfo>>(_o->map_gates.size(), [&](size_t i) { return CreateGateInfo(_fbb, _o->map_gates[i].get(), _rehasher); }) : 0;
  return ProtocolCS::World::CreateMapData(
      _fbb,
      _entity_id,
      _map_id,
      _map_type,
      _map_gates);
}

inline ActorT *Actor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ActorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Actor::UnPackTo(ActorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_type(); _o->entity.type = _e; };
  { auto _e = entity(); if (_e) _o->entity.value = ActorTypeUnion::UnPack(_e, entity_type(), _resolver); };
}

inline flatbuffers::Offset<Actor> Actor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateActor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Actor> CreateActor(flatbuffers::FlatBufferBuilder &_fbb, const ActorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_type = _o->entity.type;
  auto _entity = _o->entity.Pack(_fbb);
  return ProtocolCS::World::CreateActor(
      _fbb,
      _entity_type,
      _entity);
}

inline MoveActionInfoT *MoveActionInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MoveActionInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MoveActionInfo::UnPackTo(MoveActionInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
  { auto _e = rotation(); _o->rotation = _e; };
  { auto _e = velocity(); if (_e) _o->velocity = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
}

inline flatbuffers::Offset<MoveActionInfo> MoveActionInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveActionInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoveActionInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MoveActionInfo> CreateMoveActionInfo(flatbuffers::FlatBufferBuilder &_fbb, const MoveActionInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _rotation = _o->rotation;
  auto _velocity = _o->velocity ? _o->velocity.get() : 0;
  return ProtocolCS::World::CreateMoveActionInfo(
      _fbb,
      _entity_id,
      _position,
      _rotation,
      _velocity);
}

inline SkillActionInfoT *SkillActionInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SkillActionInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SkillActionInfo::UnPackTo(SkillActionInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = skill_id(); _o->skill_id = _e; };
  { auto _e = targets(); if (_e) { _o->targets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->targets[_i] = _e->Get(_i)->str(); } } };
  { auto _e = rotation(); _o->rotation = _e; };
}

inline flatbuffers::Offset<SkillActionInfo> SkillActionInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkillActionInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSkillActionInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SkillActionInfo> CreateSkillActionInfo(flatbuffers::FlatBufferBuilder &_fbb, const SkillActionInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _skill_id = _o->skill_id;
  auto _targets = _o->targets.size() ? _fbb.CreateVectorOfStrings(_o->targets) : 0;
  auto _rotation = _o->rotation;
  return ProtocolCS::World::CreateSkillActionInfo(
      _fbb,
      _entity_id,
      _skill_id,
      _targets,
      _rotation);
}

inline DamageInfoT *DamageInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DamageInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DamageInfo::UnPackTo(DamageInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = damage(); _o->damage = _e; };
}

inline flatbuffers::Offset<DamageInfo> DamageInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DamageInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDamageInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DamageInfo> CreateDamageInfo(flatbuffers::FlatBufferBuilder &_fbb, const DamageInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _damage = _o->damage;
  return ProtocolCS::World::CreateDamageInfo(
      _fbb,
      _entity_id,
      _damage);
}

inline StateInfoT *StateInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StateInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StateInfo::UnPackTo(StateInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = state(); _o->state = _e; };
}

inline flatbuffers::Offset<StateInfo> StateInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StateInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStateInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StateInfo> CreateStateInfo(flatbuffers::FlatBufferBuilder &_fbb, const StateInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _state = _o->state;
  return ProtocolCS::World::CreateStateInfo(
      _fbb,
      _entity_id,
      _state);
}

inline AttributeInfoT *AttributeInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AttributeInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AttributeInfo::UnPackTo(AttributeInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = max_hp(); _o->max_hp = _e; };
  { auto _e = hp(); _o->hp = _e; };
  { auto _e = max_mp(); _o->max_mp = _e; };
  { auto _e = mp(); _o->mp = _e; };
}

inline flatbuffers::Offset<AttributeInfo> AttributeInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttributeInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttributeInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AttributeInfo> CreateAttributeInfo(flatbuffers::FlatBufferBuilder &_fbb, const AttributeInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _max_hp = _o->max_hp;
  auto _hp = _o->hp;
  auto _max_mp = _o->max_mp;
  auto _mp = _o->mp;
  return ProtocolCS::World::CreateAttributeInfo(
      _fbb,
      _entity_id,
      _max_hp,
      _hp,
      _max_mp,
      _mp);
}

inline Request_LoginT *Request_Login::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_LoginT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_Login::UnPackTo(Request_LoginT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = credential(); if (_e) _o->credential = _e->str(); };
  { auto _e = hero_uid(); _o->hero_uid = _e; };
}

inline flatbuffers::Offset<Request_Login> Request_Login::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Login(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Login> CreateRequest_Login(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _credential = _o->credential.size() ? _fbb.CreateString(_o->credential) : 0;
  auto _hero_uid = _o->hero_uid;
  return ProtocolCS::World::CreateRequest_Login(
      _fbb,
      _credential,
      _hero_uid);
}

inline Reply_LoginSuccessT *Reply_LoginSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_LoginSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_LoginSuccess::UnPackTo(Reply_LoginSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hero(); if (_e) _o->hero = std::unique_ptr<HeroT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Reply_LoginSuccess> Reply_LoginSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_LoginSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _hero = _o->hero ? CreateHero(_fbb, _o->hero.get(), _rehasher) : 0;
  return ProtocolCS::World::CreateReply_LoginSuccess(
      _fbb,
      _hero);
}

inline Reply_LoginFailedT *Reply_LoginFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_LoginFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_LoginFailed::UnPackTo(Reply_LoginFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_LoginFailed> Reply_LoginFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_LoginFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_LoginFailed> CreateReply_LoginFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return ProtocolCS::World::CreateReply_LoginFailed(
      _fbb,
      _error_code);
}

inline Notify_LoadFinishT *Notify_LoadFinish::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_LoadFinishT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_LoadFinish::UnPackTo(Notify_LoadFinishT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Notify_LoadFinish> Notify_LoadFinish::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_LoadFinishT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_LoadFinish(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_LoadFinish> CreateNotify_LoadFinish(flatbuffers::FlatBufferBuilder &_fbb, const Notify_LoadFinishT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return ProtocolCS::World::CreateNotify_LoadFinish(
      _fbb);
}

inline Notify_EnterSuccessT *Notify_EnterSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_EnterSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_EnterSuccess::UnPackTo(Notify_EnterSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hero(); if (_e) _o->hero = std::unique_ptr<HeroT>(_e->UnPack(_resolver)); };
  { auto _e = map_data(); if (_e) _o->map_data = std::unique_ptr<MapDataT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Notify_EnterSuccess> Notify_EnterSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_EnterSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_EnterSuccess> CreateNotify_EnterSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _hero = _o->hero ? CreateHero(_fbb, _o->hero.get(), _rehasher) : 0;
  auto _map_data = _o->map_data ? CreateMapData(_fbb, _o->map_data.get(), _rehasher) : 0;
  return ProtocolCS::World::CreateNotify_EnterSuccess(
      _fbb,
      _hero,
      _map_data);
}

inline Notify_EnterFailedT *Notify_EnterFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_EnterFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_EnterFailed::UnPackTo(Notify_EnterFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Notify_EnterFailed> Notify_EnterFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_EnterFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_EnterFailed> CreateNotify_EnterFailed(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return ProtocolCS::World::CreateNotify_EnterFailed(
      _fbb,
      _error_code);
}

inline Request_ActionMoveT *Request_ActionMove::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_ActionMoveT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_ActionMove::UnPackTo(Request_ActionMoveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
  { auto _e = rotation(); _o->rotation = _e; };
  { auto _e = velocity(); if (_e) _o->velocity = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
}

inline flatbuffers::Offset<Request_ActionMove> Request_ActionMove::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_ActionMoveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_ActionMove(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_ActionMove> CreateRequest_ActionMove(flatbuffers::FlatBufferBuilder &_fbb, const Request_ActionMoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _rotation = _o->rotation;
  auto _velocity = _o->velocity ? _o->velocity.get() : 0;
  return ProtocolCS::World::CreateRequest_ActionMove(
      _fbb,
      _position,
      _rotation,
      _velocity);
}

inline Request_ActionSkillT *Request_ActionSkill::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_ActionSkillT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_ActionSkill::UnPackTo(Request_ActionSkillT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = skill(); _o->skill = _e; };
  { auto _e = targets(); if (_e) { _o->targets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->targets[_i] = _e->Get(_i)->str(); } } };
  { auto _e = rotation(); _o->rotation = _e; };
}

inline flatbuffers::Offset<Request_ActionSkill> Request_ActionSkill::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_ActionSkillT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_ActionSkill(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_ActionSkill> CreateRequest_ActionSkill(flatbuffers::FlatBufferBuilder &_fbb, const Request_ActionSkillT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _skill = _o->skill;
  auto _targets = _o->targets.size() ? _fbb.CreateVectorOfStrings(_o->targets) : 0;
  auto _rotation = _o->rotation;
  return ProtocolCS::World::CreateRequest_ActionSkill(
      _fbb,
      _skill,
      _targets,
      _rotation);
}

inline Request_RespawnT *Request_Respawn::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_RespawnT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_Respawn::UnPackTo(Request_RespawnT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Request_Respawn> Request_Respawn::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_RespawnT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Respawn(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Respawn> CreateRequest_Respawn(flatbuffers::FlatBufferBuilder &_fbb, const Request_RespawnT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return ProtocolCS::World::CreateRequest_Respawn(
      _fbb);
}

inline Notify_AppearT *Notify_Appear::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_AppearT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_Appear::UnPackTo(Notify_AppearT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity(); if (_e) _o->entity = std::unique_ptr<ActorT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Notify_Appear> Notify_Appear::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AppearT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_Appear(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_Appear> CreateNotify_Appear(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AppearT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity = _o->entity ? CreateActor(_fbb, _o->entity.get(), _rehasher) : 0;
  return ProtocolCS::World::CreateNotify_Appear(
      _fbb,
      _entity);
}

inline Notify_DisappearT *Notify_Disappear::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_DisappearT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_Disappear::UnPackTo(Notify_DisappearT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
}

inline flatbuffers::Offset<Notify_Disappear> Notify_Disappear::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DisappearT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_Disappear(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_Disappear> CreateNotify_Disappear(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DisappearT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  return ProtocolCS::World::CreateNotify_Disappear(
      _fbb,
      _entity_id);
}

inline Notify_UpdateT *Notify_Update::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_UpdateT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_Update::UnPackTo(Notify_UpdateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = update_data_type(); _o->update_data.type = _e; };
  { auto _e = update_data(); if (_e) _o->update_data.value = UpdateTypeUnion::UnPack(_e, update_data_type(), _resolver); };
}

inline flatbuffers::Offset<Notify_Update> Notify_Update::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UpdateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_Update(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_Update> CreateNotify_Update(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _update_data_type = _o->update_data.type;
  auto _update_data = _o->update_data.Pack(_fbb);
  return ProtocolCS::World::CreateNotify_Update(
      _fbb,
      _entity_id,
      _update_data_type,
      _update_data);
}

inline Request_EnterGateT *Request_EnterGate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_EnterGateT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_EnterGate::UnPackTo(Request_EnterGateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = gate_uid(); _o->gate_uid = _e; };
}

inline flatbuffers::Offset<Request_EnterGate> Request_EnterGate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterGateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_EnterGate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_EnterGate> CreateRequest_EnterGate(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterGateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _gate_uid = _o->gate_uid;
  return ProtocolCS::World::CreateRequest_EnterGate(
      _fbb,
      _gate_uid);
}

inline Reply_EnterGateFailedT *Reply_EnterGateFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_EnterGateFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_EnterGateFailed::UnPackTo(Reply_EnterGateFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_EnterGateFailed> Reply_EnterGateFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterGateFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_EnterGateFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_EnterGateFailed> CreateReply_EnterGateFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterGateFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return ProtocolCS::World::CreateReply_EnterGateFailed(
      _fbb,
      _error_code);
}

}  // namespace World

inline MessageRootT *MessageRoot::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MessageRootT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MessageRoot::UnPackTo(MessageRootT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message_type(); _o->message.type = _e; };
  { auto _e = message(); if (_e) _o->message.value = MessageTypeUnion::UnPack(_e, message_type(), _resolver); };
}

inline flatbuffers::Offset<MessageRoot> MessageRoot::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageRootT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessageRoot(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MessageRoot> CreateMessageRoot(flatbuffers::FlatBufferBuilder &_fbb, const MessageRootT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _message_type = _o->message.type;
  auto _message = _o->message.Pack(_fbb);
  return ProtocolCS::CreateMessageRoot(
      _fbb,
      _message_type,
      _message);
}

namespace World {

inline bool VerifyActorType(flatbuffers::Verifier &verifier, const void *obj, ActorType type) {
  switch (type) {
    case ActorType::NONE: {
      return true;
    }
    case ActorType::Hero: {
      auto ptr = reinterpret_cast<const Hero *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ActorType::Monster: {
      auto ptr = reinterpret_cast<const Monster *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyActorTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyActorType(
        verifier,  values->Get(i), types->GetEnum<ActorType>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ActorTypeUnion::UnPack(const void *obj, ActorType type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ActorType::Hero: {
      auto ptr = reinterpret_cast<const Hero *>(obj);
      return ptr->UnPack(resolver);
    }
    case ActorType::Monster: {
      auto ptr = reinterpret_cast<const Monster *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ActorTypeUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ActorType::Hero: {
      auto ptr = reinterpret_cast<const HeroT *>(value);
      return CreateHero(_fbb, ptr, _rehasher).Union();
    }
    case ActorType::Monster: {
      auto ptr = reinterpret_cast<const MonsterT *>(value);
      return CreateMonster(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ActorTypeUnion::ActorTypeUnion(const ActorTypeUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case ActorType::Hero: {
      assert(false);  // HeroT not copyable.
      break;
    }
    case ActorType::Monster: {
      assert(false);  // MonsterT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void ActorTypeUnion::Reset() {
  switch (type) {
    case ActorType::Hero: {
      auto ptr = reinterpret_cast<HeroT *>(value);
      delete ptr;
      break;
    }
    case ActorType::Monster: {
      auto ptr = reinterpret_cast<MonsterT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ActorType::NONE;
}

inline bool VerifyUpdateType(flatbuffers::Verifier &verifier, const void *obj, UpdateType type) {
  switch (type) {
    case UpdateType::NONE: {
      return true;
    }
    case UpdateType::Actor: {
      auto ptr = reinterpret_cast<const Actor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UpdateType::MoveActionInfo: {
      auto ptr = reinterpret_cast<const MoveActionInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UpdateType::SkillActionInfo: {
      auto ptr = reinterpret_cast<const SkillActionInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UpdateType::DamageInfo: {
      auto ptr = reinterpret_cast<const DamageInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UpdateType::StateInfo: {
      auto ptr = reinterpret_cast<const StateInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UpdateType::AttributeInfo: {
      auto ptr = reinterpret_cast<const AttributeInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyUpdateTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUpdateType(
        verifier,  values->Get(i), types->GetEnum<UpdateType>(i))) {
      return false;
    }
  }
  return true;
}

inline void *UpdateTypeUnion::UnPack(const void *obj, UpdateType type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case UpdateType::Actor: {
      auto ptr = reinterpret_cast<const Actor *>(obj);
      return ptr->UnPack(resolver);
    }
    case UpdateType::MoveActionInfo: {
      auto ptr = reinterpret_cast<const MoveActionInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case UpdateType::SkillActionInfo: {
      auto ptr = reinterpret_cast<const SkillActionInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case UpdateType::DamageInfo: {
      auto ptr = reinterpret_cast<const DamageInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case UpdateType::StateInfo: {
      auto ptr = reinterpret_cast<const StateInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case UpdateType::AttributeInfo: {
      auto ptr = reinterpret_cast<const AttributeInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> UpdateTypeUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case UpdateType::Actor: {
      auto ptr = reinterpret_cast<const ActorT *>(value);
      return CreateActor(_fbb, ptr, _rehasher).Union();
    }
    case UpdateType::MoveActionInfo: {
      auto ptr = reinterpret_cast<const MoveActionInfoT *>(value);
      return CreateMoveActionInfo(_fbb, ptr, _rehasher).Union();
    }
    case UpdateType::SkillActionInfo: {
      auto ptr = reinterpret_cast<const SkillActionInfoT *>(value);
      return CreateSkillActionInfo(_fbb, ptr, _rehasher).Union();
    }
    case UpdateType::DamageInfo: {
      auto ptr = reinterpret_cast<const DamageInfoT *>(value);
      return CreateDamageInfo(_fbb, ptr, _rehasher).Union();
    }
    case UpdateType::StateInfo: {
      auto ptr = reinterpret_cast<const StateInfoT *>(value);
      return CreateStateInfo(_fbb, ptr, _rehasher).Union();
    }
    case UpdateType::AttributeInfo: {
      auto ptr = reinterpret_cast<const AttributeInfoT *>(value);
      return CreateAttributeInfo(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline UpdateTypeUnion::UpdateTypeUnion(const UpdateTypeUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case UpdateType::Actor: {
      value = new ActorT(*reinterpret_cast<ActorT *>(u.value));
      break;
    }
    case UpdateType::MoveActionInfo: {
      assert(false);  // MoveActionInfoT not copyable.
      break;
    }
    case UpdateType::SkillActionInfo: {
      value = new SkillActionInfoT(*reinterpret_cast<SkillActionInfoT *>(u.value));
      break;
    }
    case UpdateType::DamageInfo: {
      value = new DamageInfoT(*reinterpret_cast<DamageInfoT *>(u.value));
      break;
    }
    case UpdateType::StateInfo: {
      value = new StateInfoT(*reinterpret_cast<StateInfoT *>(u.value));
      break;
    }
    case UpdateType::AttributeInfo: {
      value = new AttributeInfoT(*reinterpret_cast<AttributeInfoT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void UpdateTypeUnion::Reset() {
  switch (type) {
    case UpdateType::Actor: {
      auto ptr = reinterpret_cast<ActorT *>(value);
      delete ptr;
      break;
    }
    case UpdateType::MoveActionInfo: {
      auto ptr = reinterpret_cast<MoveActionInfoT *>(value);
      delete ptr;
      break;
    }
    case UpdateType::SkillActionInfo: {
      auto ptr = reinterpret_cast<SkillActionInfoT *>(value);
      delete ptr;
      break;
    }
    case UpdateType::DamageInfo: {
      auto ptr = reinterpret_cast<DamageInfoT *>(value);
      delete ptr;
      break;
    }
    case UpdateType::StateInfo: {
      auto ptr = reinterpret_cast<StateInfoT *>(value);
      delete ptr;
      break;
    }
    case UpdateType::AttributeInfo: {
      auto ptr = reinterpret_cast<AttributeInfoT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = UpdateType::NONE;
}

}  // namespace World

inline bool VerifyMessageType(flatbuffers::Verifier &verifier, const void *obj, MessageType type) {
  switch (type) {
    case MessageType::NONE: {
      return true;
    }
    case MessageType::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Notify_UnauthedAccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Request_Login: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_Login *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_LoginSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_LoginFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Request_Join: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_Join *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_JoinSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_JoinSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_JoinFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_JoinFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Request_HeroList: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_HeroList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_HeroList: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_HeroList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Request_CreateHero: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_CreateHero *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_CreateHeroSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CreateHeroSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_CreateHeroFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CreateHeroFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Request_DeleteHero: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_DeleteHero *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_DeleteHeroSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_DeleteHeroSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_DeleteHeroFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_DeleteHeroFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Request_Login: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_Login *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_LoginSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_LoginFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Notify_LoadFinish: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_LoadFinish *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Notify_EnterSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_EnterSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Notify_EnterFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_EnterFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Request_ActionMove: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_ActionMove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Request_ActionSkill: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_ActionSkill *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Notify_Appear: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_Appear *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Notify_Disappear: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_Disappear *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Notify_Update: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_Update *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Request_Respawn: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_Respawn *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Request_EnterGate: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_EnterGate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Reply_EnterGateFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterGateFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageType(
        verifier,  values->Get(i), types->GetEnum<MessageType>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MessageTypeUnion::UnPack(const void *obj, MessageType type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case MessageType::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Notify_UnauthedAccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Request_Login: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_Login *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_LoginSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_LoginFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Request_Join: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_Join *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_JoinSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_JoinSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_JoinFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_JoinFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Request_HeroList: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_HeroList *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_HeroList: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_HeroList *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Request_CreateHero: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_CreateHero *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_CreateHeroSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CreateHeroSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_CreateHeroFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CreateHeroFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Request_DeleteHero: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_DeleteHero *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_DeleteHeroSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_DeleteHeroSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_DeleteHeroFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_DeleteHeroFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Request_Login: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_Login *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_LoginSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_LoginFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Notify_LoadFinish: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_LoadFinish *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Notify_EnterSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_EnterSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Notify_EnterFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_EnterFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Request_ActionMove: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_ActionMove *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Request_ActionSkill: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_ActionSkill *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Notify_Appear: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_Appear *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Notify_Disappear: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_Disappear *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Notify_Update: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_Update *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Request_Respawn: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_Respawn *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Request_EnterGate: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_EnterGate *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Reply_EnterGateFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterGateFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MessageTypeUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case MessageType::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Notify_UnauthedAccessT *>(value);
      return CreateNotify_UnauthedAccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Request_Login: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_LoginT *>(value);
      return CreateRequest_Login(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_LoginSuccessT *>(value);
      return CreateReply_LoginSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_LoginFailedT *>(value);
      return CreateReply_LoginFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Request_Join: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_JoinT *>(value);
      return CreateRequest_Join(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_JoinSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_JoinSuccessT *>(value);
      return CreateReply_JoinSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_JoinFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_JoinFailedT *>(value);
      return CreateReply_JoinFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Request_HeroList: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_HeroListT *>(value);
      return CreateRequest_HeroList(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_HeroList: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_HeroListT *>(value);
      return CreateReply_HeroList(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Request_CreateHero: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_CreateHeroT *>(value);
      return CreateRequest_CreateHero(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_CreateHeroSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CreateHeroSuccessT *>(value);
      return CreateReply_CreateHeroSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_CreateHeroFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CreateHeroFailedT *>(value);
      return CreateReply_CreateHeroFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Request_DeleteHero: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_DeleteHeroT *>(value);
      return CreateRequest_DeleteHero(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_DeleteHeroSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_DeleteHeroSuccessT *>(value);
      return CreateReply_DeleteHeroSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_DeleteHeroFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_DeleteHeroFailedT *>(value);
      return CreateReply_DeleteHeroFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Request_Login: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_LoginT *>(value);
      return CreateRequest_Login(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_LoginSuccessT *>(value);
      return CreateReply_LoginSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_LoginFailedT *>(value);
      return CreateReply_LoginFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Notify_LoadFinish: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_LoadFinishT *>(value);
      return CreateNotify_LoadFinish(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Notify_EnterSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_EnterSuccessT *>(value);
      return CreateNotify_EnterSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Notify_EnterFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_EnterFailedT *>(value);
      return CreateNotify_EnterFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Request_ActionMove: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_ActionMoveT *>(value);
      return CreateRequest_ActionMove(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Request_ActionSkill: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_ActionSkillT *>(value);
      return CreateRequest_ActionSkill(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Notify_Appear: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_AppearT *>(value);
      return CreateNotify_Appear(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Notify_Disappear: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_DisappearT *>(value);
      return CreateNotify_Disappear(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Notify_Update: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_UpdateT *>(value);
      return CreateNotify_Update(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Request_Respawn: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_RespawnT *>(value);
      return CreateRequest_Respawn(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Request_EnterGate: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_EnterGateT *>(value);
      return CreateRequest_EnterGate(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Reply_EnterGateFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterGateFailedT *>(value);
      return CreateReply_EnterGateFailed(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MessageTypeUnion::MessageTypeUnion(const MessageTypeUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case MessageType::Notify_UnauthedAccess: {
      value = new ProtocolCS::Notify_UnauthedAccessT(*reinterpret_cast<ProtocolCS::Notify_UnauthedAccessT *>(u.value));
      break;
    }
    case MessageType::Login_Request_Login: {
      value = new ProtocolCS::Login::Request_LoginT(*reinterpret_cast<ProtocolCS::Login::Request_LoginT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_LoginSuccess: {
      value = new ProtocolCS::Login::Reply_LoginSuccessT(*reinterpret_cast<ProtocolCS::Login::Reply_LoginSuccessT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_LoginFailed: {
      value = new ProtocolCS::Login::Reply_LoginFailedT(*reinterpret_cast<ProtocolCS::Login::Reply_LoginFailedT *>(u.value));
      break;
    }
    case MessageType::Login_Request_Join: {
      value = new ProtocolCS::Login::Request_JoinT(*reinterpret_cast<ProtocolCS::Login::Request_JoinT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_JoinSuccess: {
      value = new ProtocolCS::Login::Reply_JoinSuccessT(*reinterpret_cast<ProtocolCS::Login::Reply_JoinSuccessT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_JoinFailed: {
      value = new ProtocolCS::Login::Reply_JoinFailedT(*reinterpret_cast<ProtocolCS::Login::Reply_JoinFailedT *>(u.value));
      break;
    }
    case MessageType::Login_Request_HeroList: {
      value = new ProtocolCS::Login::Request_HeroListT(*reinterpret_cast<ProtocolCS::Login::Request_HeroListT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_HeroList: {
      assert(false);  // ProtocolCS::Login::Reply_HeroListT not copyable.
      break;
    }
    case MessageType::Login_Request_CreateHero: {
      value = new ProtocolCS::Login::Request_CreateHeroT(*reinterpret_cast<ProtocolCS::Login::Request_CreateHeroT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_CreateHeroSuccess: {
      assert(false);  // ProtocolCS::Login::Reply_CreateHeroSuccessT not copyable.
      break;
    }
    case MessageType::Login_Reply_CreateHeroFailed: {
      value = new ProtocolCS::Login::Reply_CreateHeroFailedT(*reinterpret_cast<ProtocolCS::Login::Reply_CreateHeroFailedT *>(u.value));
      break;
    }
    case MessageType::Login_Request_DeleteHero: {
      value = new ProtocolCS::Login::Request_DeleteHeroT(*reinterpret_cast<ProtocolCS::Login::Request_DeleteHeroT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_DeleteHeroSuccess: {
      value = new ProtocolCS::Login::Reply_DeleteHeroSuccessT(*reinterpret_cast<ProtocolCS::Login::Reply_DeleteHeroSuccessT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_DeleteHeroFailed: {
      value = new ProtocolCS::Login::Reply_DeleteHeroFailedT(*reinterpret_cast<ProtocolCS::Login::Reply_DeleteHeroFailedT *>(u.value));
      break;
    }
    case MessageType::World_Request_Login: {
      value = new ProtocolCS::World::Request_LoginT(*reinterpret_cast<ProtocolCS::World::Request_LoginT *>(u.value));
      break;
    }
    case MessageType::World_Reply_LoginSuccess: {
      assert(false);  // ProtocolCS::World::Reply_LoginSuccessT not copyable.
      break;
    }
    case MessageType::World_Reply_LoginFailed: {
      value = new ProtocolCS::World::Reply_LoginFailedT(*reinterpret_cast<ProtocolCS::World::Reply_LoginFailedT *>(u.value));
      break;
    }
    case MessageType::World_Notify_LoadFinish: {
      value = new ProtocolCS::World::Notify_LoadFinishT(*reinterpret_cast<ProtocolCS::World::Notify_LoadFinishT *>(u.value));
      break;
    }
    case MessageType::World_Notify_EnterSuccess: {
      assert(false);  // ProtocolCS::World::Notify_EnterSuccessT not copyable.
      break;
    }
    case MessageType::World_Notify_EnterFailed: {
      value = new ProtocolCS::World::Notify_EnterFailedT(*reinterpret_cast<ProtocolCS::World::Notify_EnterFailedT *>(u.value));
      break;
    }
    case MessageType::World_Request_ActionMove: {
      assert(false);  // ProtocolCS::World::Request_ActionMoveT not copyable.
      break;
    }
    case MessageType::World_Request_ActionSkill: {
      value = new ProtocolCS::World::Request_ActionSkillT(*reinterpret_cast<ProtocolCS::World::Request_ActionSkillT *>(u.value));
      break;
    }
    case MessageType::World_Notify_Appear: {
      assert(false);  // ProtocolCS::World::Notify_AppearT not copyable.
      break;
    }
    case MessageType::World_Notify_Disappear: {
      value = new ProtocolCS::World::Notify_DisappearT(*reinterpret_cast<ProtocolCS::World::Notify_DisappearT *>(u.value));
      break;
    }
    case MessageType::World_Notify_Update: {
      value = new ProtocolCS::World::Notify_UpdateT(*reinterpret_cast<ProtocolCS::World::Notify_UpdateT *>(u.value));
      break;
    }
    case MessageType::World_Request_Respawn: {
      value = new ProtocolCS::World::Request_RespawnT(*reinterpret_cast<ProtocolCS::World::Request_RespawnT *>(u.value));
      break;
    }
    case MessageType::World_Request_EnterGate: {
      value = new ProtocolCS::World::Request_EnterGateT(*reinterpret_cast<ProtocolCS::World::Request_EnterGateT *>(u.value));
      break;
    }
    case MessageType::World_Reply_EnterGateFailed: {
      value = new ProtocolCS::World::Reply_EnterGateFailedT(*reinterpret_cast<ProtocolCS::World::Reply_EnterGateFailedT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void MessageTypeUnion::Reset() {
  switch (type) {
    case MessageType::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<ProtocolCS::Notify_UnauthedAccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Request_Login: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Request_LoginT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_LoginSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_LoginFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Request_Join: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Request_JoinT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_JoinSuccess: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_JoinSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_JoinFailed: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_JoinFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Request_HeroList: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Request_HeroListT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_HeroList: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_HeroListT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Request_CreateHero: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Request_CreateHeroT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_CreateHeroSuccess: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_CreateHeroSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_CreateHeroFailed: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_CreateHeroFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Request_DeleteHero: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Request_DeleteHeroT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_DeleteHeroSuccess: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_DeleteHeroSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_DeleteHeroFailed: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_DeleteHeroFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Request_Login: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Request_LoginT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Reply_LoginSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Reply_LoginFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Notify_LoadFinish: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Notify_LoadFinishT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Notify_EnterSuccess: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Notify_EnterSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Notify_EnterFailed: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Notify_EnterFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Request_ActionMove: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Request_ActionMoveT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Request_ActionSkill: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Request_ActionSkillT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Notify_Appear: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Notify_AppearT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Notify_Disappear: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Notify_DisappearT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Notify_Update: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Notify_UpdateT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Request_Respawn: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Request_RespawnT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Request_EnterGate: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Request_EnterGateT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Reply_EnterGateFailed: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Reply_EnterGateFailedT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = MessageType::NONE;
}

inline const ProtocolCS::MessageRoot *GetMessageRoot(const void *buf) {
  return flatbuffers::GetRoot<ProtocolCS::MessageRoot>(buf);
}

inline MessageRoot *GetMutableMessageRoot(void *buf) {
  return flatbuffers::GetMutableRoot<MessageRoot>(buf);
}

inline const char *MessageRootIdentifier() {
  return "PTCS";
}

inline bool MessageRootBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MessageRootIdentifier());
}

inline bool VerifyMessageRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ProtocolCS::MessageRoot>(MessageRootIdentifier());
}

inline void FinishMessageRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ProtocolCS::MessageRoot> root) {
  fbb.Finish(root, MessageRootIdentifier());
}

inline std::unique_ptr<MessageRootT> UnPackMessageRoot(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<MessageRootT>(GetMessageRoot(buf)->UnPack(res));
}

}  // namespace ProtocolCS

#endif  // FLATBUFFERS_GENERATED_PROTOCOLCS_PROTOCOLCS_H_
